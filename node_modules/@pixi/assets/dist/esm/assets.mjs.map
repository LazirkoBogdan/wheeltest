{"version":3,"file":"assets.mjs","sources":["../../src/BackgroundLoader.ts","../../src/utils/convertToList.ts","../../src/utils/createStringVariations.ts","../../src/utils/isSingleItem.ts","../../src/cache/Cache.ts","../../src/loader/Loader.ts","../../src/resolver/Resolver.ts","../../src/Assets.ts","../../src/AssetExtension.ts","../../src/cache/parsers/cacheTextureArray.ts","../../src/loader/parsers/LoaderParser.ts","../../src/loader/parsers/loadJson.ts","../../src/loader/parsers/loadTxt.ts","../../src/loader/parsers/loadWebFont.ts","../../src/loader/parsers/WorkerManager.ts","../../src/loader/parsers/textures/utils/checkExtension.ts","../../src/loader/parsers/textures/utils/createTexture.ts","../../src/loader/parsers/textures/loadTexture.ts","../../src/loader/parsers/textures/loadSVG.ts","../../src/resolver/parsers/resolveTextureUrl.ts","../../src/detections/parsers/detectAvif.ts","../../src/detections/parsers/detectWebp.ts","../../src/detections/parsers/detectDefaults.ts"],"sourcesContent":["import type { LoadAsset } from './loader';\nimport type { Loader } from './loader/Loader';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof PIXI\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: LoadAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: LoadAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        // eslint-disable-next-line no-console\n        if (this.verbose)console.log('[BackgroundLoader] assets: ', this._assetList);\n\n        if (this._isActive && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            this._next();\n        }\n    }\n\n    /**\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    /** Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset. */\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n}\n","export const convertToList = <T>(input: string | T | (string | T)[], transform?: (input: string) => T): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string')\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","import { utils } from '@pixi/core';\nimport { convertToList, isSingleItem } from '../utils';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser, LoadAsset } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof PIXI\n * @class AssetLoader\n */\nexport class Loader\n{\n    private _parsers: LoaderParser[] = [];\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: LoadAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.load && parser.test?.(url, data, this))\n                {\n                    asset = await parser.load(url, data, this);\n                    result.parser = parser;\n\n                    break;\n                }\n            }\n\n            if (!result.parser)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);\n                // #endif\n\n                return null;\n            }\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads an asset(s) using the parsers added to the Loader.\n     * @example\n     * // single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     * @example\n     * // multiple assets:\n     * const assets = await  Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - a function that gets called when the progress changes\n     */\n    public async load(\n        assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<{[key: string]: any} | any>\n    {\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<LoadAsset>(assetsToLoadIn, (item) => ({\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads an asset(s). Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<LoadAsset>(assetsToUnloadIn, (item) => ({\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                loadPromise.parser?.unload?.(loadedAsset, asset, this);\n\n                delete this.promiseCache[url];\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): LoaderParser[]\n    {\n        return this._parsers;\n    }\n}\n","import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\nimport type { ResolveAsset, PreferOrder, ResolveURLParser, ResolverManifest, ResolverBundle } from './types';\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```\n *  resolver.prefer({\n *      params:{\n *          format:'webp',\n *          resolution: 2,\n *      }\n *  })\n *\n *  resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n *  resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _assetMap: Record<string, ResolveAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolveAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: ResolverManifest;\n    private _bundles: Record<string, string[]> = {};\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *    {\n     *      resolution:2,\n     *      format:'png'\n     *      src: 'image@2x.png'\n     *    },\n     *    {\n     *      resolution:1,\n     *      format:'png'\n     *      src: 'image.png'\n     *    }\n     * ]);\n     *\n     * // with a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *    'image@2x.png'\n     *    'image.png'\n     * ]);\n     * @\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this._preferredOrder = [];\n\n        this._resolverHash = {};\n        this._assetMap = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: ResolverManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     *  resolver.addBundle('animals', {\n     *    bunny: 'bunny.png',\n     *    chicken: 'chicken.png',\n     *    thumper: 'thumper.png',\n     *  });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                if (typeof asset.name === 'string')\n                {\n                    assetNames.push(asset.name);\n                }\n                else\n                {\n                    assetNames.push(...asset.name);\n                }\n\n                this.add(asset.name, asset.srcs);\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                assetNames.push(key);\n                this.add(key, assets[key]);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // single key, single asset:\n     * resolver.add('foo', 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // multiple keys, single asset:\n     * resolver.add(['foo', 'boo'], 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // multiple keys, multiple assets:\n     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // add custom data attached to the resolver\n     * Resolver.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options\n     * );\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => {src: 'bunny.png', data: {scaleMode: SCALE_MODES.NEAREST}}\n     * @param keysIn - The keys to map, can be an array or a single key\n     * @param assetsIn - The assets to associate with the key(s)\n     * @param data - The data that will be attached to the object that resolved object.\n     */\n    public add(keysIn: string | string[], assetsIn: string | ResolveAsset | (ResolveAsset | string)[], data?: unknown): void\n    {\n        const keys: string[] = convertToList<string>(keysIn);\n\n        keys.forEach((key) =>\n        {\n            if (this._assetMap[key])\n            {\n                // #if _DEBUG\n                console.warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        });\n\n        if (!Array.isArray(assetsIn))\n        {\n            if (typeof assetsIn === 'string')\n            {\n                assetsIn = createStringVariations(assetsIn);\n            }\n            else\n            {\n                assetsIn = [assetsIn];\n            }\n        }\n\n        const assetMap: ResolveAsset[] = assetsIn.map((asset): ResolveAsset =>\n        {\n            let formattedAsset = asset as ResolveAsset;\n\n            // check if is a string\n            if (typeof asset === 'string')\n            {\n                // first see if it contains any {} tags...\n\n                let parsed = false;\n\n                for (let i = 0; i < this._parsers.length; i++)\n                {\n                    const parser = this._parsers[i];\n\n                    if (parser.test(asset))\n                    {\n                        formattedAsset = parser.parse(asset);\n                        parsed = true;\n                        break;\n                    }\n                }\n\n                if (!parsed)\n                {\n                    formattedAsset = {\n                        src: asset,\n                    };\n                }\n            }\n\n            if (!formattedAsset.format)\n            {\n                formattedAsset.format = formattedAsset.src.split('.').pop();\n            }\n\n            if (!formattedAsset.alias)\n            {\n                formattedAsset.alias = keys;\n            }\n\n            if (this._basePath || this._rootPath)\n            {\n                formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n            }\n\n            formattedAsset.data = formattedAsset.data ?? data;\n\n            return formattedAsset;\n        });\n\n        keys.forEach((key) =>\n        {\n            this._assetMap[key] = assetMap;\n        });\n    }\n\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // manifest example\n     * const manifest = {\n     *   bundles:[{\n     *      name:'load-screen',\n     *      assets:[\n     *          {\n     *             name: 'background',\n     *             srcs: 'sunset.png',\n     *          },\n     *          {\n     *             name: 'bar',\n     *             srcs: 'load-bar.{png,webp}',\n     *          }\n     *      ]\n     *   },\n     *   {\n     *      name:'game-screen',\n     *      assets:[\n     *          {\n     *             name: 'character',\n     *             srcs: 'robot.png',\n     *          },\n     *          {\n     *             name: 'enemy',\n     *             srcs: 'bad-guy.png',\n     *          }\n     *      ]\n     *   }]\n     * }}\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: string | string[]):\n    Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolveAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                out[bundleId] = this.resolve(assetNames) as Record<string, ResolveAsset>;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: string | string[]): string | Record<string, string>\n    {\n        const result = this.resolve(key);\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolveAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolveAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => {src:'bunny.png'}\n     *\n     * // will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => {src:'another-thing.png'}\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolveAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    const bestAsset = assets[0];\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey])\n                                {\n                                    return asset[priorityKey] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    let src = key;\n\n                    if (this._basePath || this._rootPath)\n                    {\n                        src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n                    }\n\n                    // if the resolver fails we just pass back the key assuming its a url\n                    this._resolverHash[key] = {\n                        src,\n                    };\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolveAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred =  this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n}\n","import { extensions, ExtensionType } from '@pixi/core';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport type { FormatDetectionParser } from './detections';\nimport type {\n    LoadAsset,\n    LoaderParser\n} from './loader';\nimport { Loader } from './loader/Loader';\nimport type { PreferOrder, ResolveAsset, ResolverBundle, ResolverManifest, ResolveURLParser } from './resolver';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Initialization options object for Asset Class.\n * @memberof PIXI\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | ResolverManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /** the formats you prefer, by default this will be:  ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: string | string[];\n    };\n\n    // advanced users can add custom parsers and and preferences for how things are resolved\n    /** loader options to configure the loader with, currently only parsers! */\n    loader?: {\n        /** custom parsers can be added here, for example something that could load a sound or a 3D model */\n        parsers?: LoaderParser[];\n        // more...\n    };\n    /** resolver specific options */\n    resolver?: {\n        /**\n         * a list of urlParsers, these can read the URL and pick put the various options.\n         * for example there is a texture URL parser that picks our resolution and file format.\n         * You can add custom ways to read URLs and extract information here.\n         */\n        urlParsers?: ResolveURLParser[];\n        /**\n         * a list of preferOrders that let the resolver know which asset to pick.\n         * already built-in we have a texture preferOrders that let the resolve know which asset to prefer\n         * if it has multiple assets to pick from (resolution/formats etc)\n         */\n        preferOrders?: PreferOrder[];\n    };\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @memberof PIXI\n * @namespace Assets\n *\n * Only one Asset Class exists accessed via the Global Asset object.\n *\n * It has four main responsibilities:\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4: Allow developers to unload assets and clear the cache.\n *\n * It also has a few advanced features:\n * 1. Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n *\n *\n * Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once.\n *\n * for example:\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * //promise1 === promise2\n * ```\n * here both promises will be the same. Once resolved.. forever resolved! It makes for really easy resource management!\n *\n * Out of the box it supports the following files:\n * * textures (avif, webp, png, jpg, gif)\n * * sprite sheets (json)\n * * bitmap fonts (xml, fnt, txt)\n * * web fonts (ttf, woff, woff2)\n * * json files (json)\n * * text files (txt)\n *\n * More types can be added fairly easily by creating additional loader parsers.\n *\n * ### Textures\n * - Textures are loaded as ImageBitmap on a worker thread where possible.\n * Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images\n *  but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)\n * #### Sprite sheets\n * - it's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name:\n *\n * `my-spritesheet{resolution}.{imageFormat}.json`\n *\n * for example:\n *\n * `my-spritesheet@2x.webp.json` // 2x resolution, WebP sprite sheet\n * `my-spritesheet@0.5x.png.json` // 0.5x resolution, png sprite sheet\n *\n * This is optional! you can just load a sprite sheet as normal,\n * This is only useful if you have a bunch of different res / formatted spritesheets\n *\n * ### Fonts\n * * Web fonts will be loaded with all weights.\n * it is possible to load only specific weights by doing the following:\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * // load specific weights..\n * await Assets.load({\n *    data: {\n *      weights: ['normal'], // only loads the weight\n *    },\n *    src: `outfit.woff2`,\n * });\n *\n * // load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * ### Background Loading\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n *\n * ### Manifest and Bundles\n * - Manifest is a JSON file that contains a list of all assets and their properties.\n * - Bundles are a way to group assets together.\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * // manifest example\n * const manifest = {\n *   bundles:[{\n *      name:'load-screen',\n *      assets:[\n *          {\n *             name: 'background',\n *             srcs: 'sunset.png',\n *          },\n *          {\n *             name: 'bar',\n *             srcs: 'load-bar.{png,webp}',\n *          }\n *      ]\n *   },\n *   {\n *      name:'game-screen',\n *      assets:[\n *          {\n *             name: 'character',\n *             srcs: 'robot.png',\n *          },\n *          {\n *             name: 'enemy',\n *             srcs: 'bad-guy.png',\n *          }\n *      ]\n *   }]\n * }}\n *\n * await Asset.init({\n *  manifest\n * });\n *\n * // load a bundle..\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // load another..\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /**\n     * The loader, loads stuff!\n     * @type {PIXI.AssetLoader}\n     */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {PIXI.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Asset manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            console.warn('[Assets]AssetManager already initialized, did you load before calling this Asset.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<ResolverManifest>(manifest) as ResolverManifest;\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref =  options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        let formats: string[] = [];\n\n        if (options.texturePreference?.format)\n        {\n            const formatPref = options.texturePreference?.format;\n\n            formats = (typeof formatPref === 'string') ? [formatPref] : formatPref;\n\n            // we should remove any formats that are not supported by the browser\n            for (const detection of this._detections)\n            {\n                if (!await detection.test())\n                {\n                    formats = await detection.remove(formats);\n                }\n            }\n        }\n        else\n        {\n            // we should add any formats that are supported by the browser\n            for (const detection of this._detections)\n            {\n                if (await detection.test())\n                {\n                    formats = await detection.add(formats);\n                }\n            }\n        }\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // simple\n     * Assets.add('bunnyBooBoo', 'bunny.png');\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // multiple keys:\n     * Assets.add(['burger', 'chicken'], 'bunny.png');\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options\n     * );\n     *\n     * // multiple assets,\n     *\n     * // the following all do the same thing:\n     *\n     * Assets.add('bunnyBooBoo', 'bunny{png,webp}');\n     *\n     * Assets.add('bunnyBooBoo', [\n     * 'bunny.png',\n     * 'bunny.webp'\n     * ]);\n     *\n     * Assets.add('bunnyBooBoo', [\n     *    {\n     *       format:'png',\n     *       src:'bunny.png',\n     *    },\n     *    {\n     *       format:'webp',\n     *       src:'bunny.webp',\n     *    }\n     * ]);\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // will try to load WebP if available\n     * @param keysIn - the key or keys that you will reference when loading this asset\n     * @param assetsIn - the asset or assets that will be chosen from when loading via the specified key\n     * @param data - asset-specific data that will be passed to the loaders\n     * - Useful if you want to initiate loaded objects with specific data\n     */\n    public add(keysIn: string | string[], assetsIn: string | (ResolveAsset | string)[], data?: unknown): void\n    {\n        this.resolver.add(keysIn, assetsIn, data);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T=any>(\n        urls: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray = convertToList<ResolveAsset>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    this.resolver.add(url.src as string, url);\n\n                    return url.src;\n                }\n\n                return url;\n            });\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     *  PIXI.Assets.addBundle('animals', {\n     *    bunny: 'bunny.png',\n     *    chicken: 'chicken.png',\n     *    thumper: 'thumper.png',\n     *  });\n     *\n     * const assets = await PIXI.Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * // manifest example\n     * const manifest = {\n     *   bundles:[{\n     *      name:'load-screen',\n     *      assets:[\n     *          {\n     *             name: 'background',\n     *             srcs: 'sunset.png',\n     *          },\n     *          {\n     *             name: 'bar',\n     *             srcs: 'load-bar.{png,webp}',\n     *          }\n     *      ]\n     *   },\n     *   {\n     *      name:'game-screen',\n     *      assets:[\n     *          {\n     *             name: 'character',\n     *             srcs: 'robot.png',\n     *          },\n     *          {\n     *             name: 'enemy',\n     *             srcs: 'bad-guy.png',\n     *          }\n     *      ]\n     *   }]\n     * }}\n     *\n     * await Asset.init({\n     *  manifest\n     * });\n     *\n     * // load a bundle..\n     * loadScreenAssets = await PIXI.Assets.loadBundle('load-screen');\n     * // load another..\n     * gameScreenAssets = await PIXI.Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: string | string[], onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. it will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * PIXI.Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await PIXI.Assets.loadBundle('bunny.png'); // will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * await PIXI.Assets.init({\n     *    manifest: {\n     *       bundles: [\n     *       {\n     *          name:'load-screen',\n     *          assets:[...]\n     *       }\n     *       ...]\n     *   }\n     * });\n     *\n     * PIXI.Assets.backgroundLoadBundle('load-screen');\n     *\n     * // later on in your app...\n     * await PIXI.Assets.loadBundle('load-screen'); // will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `PIXI.Assets.load` instead.\n     * (remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T=any>(keys: string | string[]): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolveAsset | Record<string, ResolveAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = Object.values(resolveResults);\n        const resolveKeys = Object.keys(resolveResults);\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult, i) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            out[resolveKeys[i]] = asset;\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * * it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * myImageTexture <-- will now be destroyed.\n     *\n     * // unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: string | string[] | LoadAsset | LoadAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | LoadAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * PIXI.Assets.addBundle({\n     *   'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await PIXI.Assets.loadBundle('thumper');\n     *\n     * // now to unload..\n     *\n     * await await PIXI.Assets.unloadBundle('thumper');\n     *\n     * // all assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolveAsset | Record<string, ResolveAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\n","import { extensions, ExtensionType } from '@pixi/core';\nimport type { LoaderParser } from './loader';\nimport type { CacheParser } from './cache';\nimport type { FormatDetectionParser } from './detections';\nimport type { ResolveURLParser } from './resolver';\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @memberof PIXI\n */\ninterface AssetExtension<ASSET = any, META_DATA = any>\n{\n    extension: ExtensionType.Asset,\n    loader?: Partial<LoaderParser<ASSET, META_DATA>>,\n    resolver?: Partial<ResolveURLParser>,\n    cache?: Partial<CacheParser<ASSET>>,\n    detection?: Partial<FormatDetectionParser>,\n}\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n\nexport type { AssetExtension };\n","import { extensions, ExtensionType, Texture } from '@pixi/core';\nimport type { CacheParser } from '../CacheParser';\n\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: ExtensionType.CacheParser,\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n\nextensions.add(cacheTextureArray);\n","import type { ExtensionMetadata } from '@pixi/core';\nimport type { Loader } from '../Loader';\nimport type { LoadAsset } from '../types';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension\n * test. The higher priority parsers will be checked first.\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * All functions are optional here. The flow:\n *\n * for every asset,\n *\n * 1. `parser.test()`: Test the asset url.\n * 2. `parser.load()`: If test passes call the load function with the url\n * 3. `parser.testParse()`: Test to see if the asset should be parsed by the plugin\n * 4. `parse.parse()`: If test is parsed, then run the parse function on the asset.\n *\n * some plugins may only be used for parsing,\n * some only for loading\n * and some for both!\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any>\n{\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: Record<string, any>\n    /**\n     * each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful than\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => void;\n}\n","import { settings, utils, extensions, ExtensionType } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\n/** simple loader plugin for loading json data */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.json'));\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} as LoaderParser;\n\nextensions.add(loadJson);\n","import { settings, utils, extensions, ExtensionType } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\n/** Simple loader plugin for loading text data */\nexport const loadTxt = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.txt'));\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} as LoaderParser;\n\nextensions.add(loadTxt);\n","import { extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoadAsset } from '../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = ['normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFonts = ['woff', 'woff2', 'ttf', 'otf'];\n\nexport type LoadFontData = {\n    family: string;\n    display: string;\n    featureSettings: string;\n    stretch: string;\n    style: string;\n    unicodeRange: string;\n    variant: string;\n    weights: string[];\n};\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/tital-one.woff' turns into 'Titan One'\n * @param url - File url\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = utils.path.extname(url);\n    const name = utils.path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTitleCase = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(' ');\n\n    return nameTitleCase;\n}\n\n/** Web font loader plugin */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        const tempURL = url.split('?')[0];\n        const extension = tempURL.split('.').pop();\n\n        return validFonts.includes(extension);\n    },\n\n    async load(url: string, options?: LoadAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        // Prevent loading font if navigator is not online\n        if (!globalThis.navigator.onLine)\n        {\n            throw new Error('[loadWebFont] Cannot load font - navigator is offline');\n        }\n\n        const fonts = settings.ADAPTER.getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${url})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        console.warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));\n    }\n} as LoaderParser<FontFace | FontFace[]>;\n\nextensions.add(loadWebFont);\n","let UUID = 0;\nlet MAX_WORKERS: number;\n\nconst workerCode = {\n    id: 'loadImageBitmap',\n    code: `\n    self.onmessage = function(event) {\n\n        async function loadImageBitmap(url)\n        {\n            const response = await fetch(url);\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n            return imageBitmap;\n        }\n\n        loadImageBitmap(event.data.data[0]).then(imageBitmap => {\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }).catch(error => {\n            self.postMessage({\n                data: null,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        });\n    }`,\n};\n\nlet workerURL: string;\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private resolveHash: {[key: string]: (...param: any[]) => void};\n    private readonly workerPool: Worker[];\n    private readonly queue: { id: string; arguments: any[]; resolve: (...param: any[]) => void }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n\n    constructor()\n    {\n        this.workerPool = [];\n        this.queue = [];\n\n        this.resolveHash = {};\n    }\n\n    public loadImageBitmap(src: string): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this.workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            if (!workerURL)\n            {\n                workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: 'application/javascript' }));\n            }\n\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new Worker(workerURL);\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this.complete(event.data);\n\n                this.returnWorker(event.target as Worker);\n                this.next();\n            });\n        }\n\n        return worker;\n    }\n\n    private returnWorker(worker: Worker)\n    {\n        this.workerPool.push(worker);\n    }\n\n    private complete(data: any): void\n    {\n        const result = data.data;\n\n        this.resolveHash[data.uuid](result);\n\n        this.resolveHash[data.uuid] = null;\n    }\n\n    private _run(id: string, args: any[]): Promise<any>\n    {\n        this._initWorkers();\n        // push into the queue...\n\n        const promise =  new Promise((resolve) =>\n        {\n            this.queue.push({ id, arguments: args, resolve });\n        });\n\n        this.next();\n\n        return promise;\n    }\n\n    private next(): void\n    {\n        // nothing to do\n        if (!this.queue.length) return;\n\n        const worker = this.getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this.queue.pop();\n\n        const id = toDo.id;\n\n        this.resolveHash[UUID] = toDo.resolve;\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n","import { utils } from '@pixi/core';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = utils.path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext.toLowerCase());\n    }\n\n    return ext.toLowerCase() === extension;\n}\n","import type { BaseTexture } from '@pixi/core';\nimport { Texture } from '@pixi/core';\nimport type { Loader } from '../../../Loader';\n\nexport function createTexture(base: BaseTexture, loader: Loader, url: string)\n{\n    const texture = new Texture(base);\n\n    // make sure to nuke the promise if a texture is destroyed..\n    texture.baseTexture.on('dispose', () =>\n    {\n        delete loader.promiseCache[url];\n    });\n\n    return texture;\n}\n","import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { checkExtension } from './utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImages = ['.jpg', '.png', '.jpeg', '.avif', '.webp'];\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n */\nexport const loadTextures = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n    },\n\n    test(url: string): boolean\n    {\n        let isValidBase64Suffix = false;\n\n        for (let i = 0; i < validImages.length; i++)\n        {\n            if (url.indexOf(`data:image/${validImages[i].slice(1)}`) === 0)\n            {\n                isValidBase64Suffix = true;\n                break;\n            }\n        }\n\n        return isValidBase64Suffix || checkExtension(url, validImages);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap)\n        {\n            src = this.config.preferWorkers ? await WorkerManager.loadImageBitmap(url) : await loadImageBitmap(url);\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = 'anonymous';\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions>;\n\nextensions.add(loadTextures);\n","import { settings, utils, BaseTexture, ExtensionType, SVGResource } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { loadTextures } from './loadTexture';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\n/** Loads SVG's into Textures */\nexport const loadSVG = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.svg'));\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return SVGResource.test(data);\n    },\n\n    async parse(asset: string, data: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        const src = new SVGResource(asset, data?.data?.resourceOptions);\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(asset),\n            ...data?.data,\n        });\n\n        base.resource.src = asset;\n\n        const texture = createTexture(base, loader, asset);\n\n        if (!data?.data?.resourceOptions?.autoLoad)\n        {\n            await src.load();\n        }\n\n        return texture;\n    },\n\n    async load(url: string, _options: LoadAsset): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        return response.text();\n    },\n\n    unload: loadTextures.unload,\n\n} as LoaderParser<Texture | string, IBaseTextureOptions>;\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport { loadTextures } from '../../loader';\n\nimport type { ResolveAsset, ResolveURLParser } from '../types';\n\nexport const resolveTextureUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: loadTextures.test,\n    parse: (value: string): ResolveAsset =>\n        ({\n            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} as ResolveURLParser;\n\nextensions.add(resolveTextureUrl);\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        // eslint-disable-next-line max-len\n        const avifData = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=';\n        const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n\nextensions.add(detectAvif);\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        const webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n\nextensions.add(detectWebp);\n","import { extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n\nextensions.add(detectDefaults);\n"],"names":[],"mappings":"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"}