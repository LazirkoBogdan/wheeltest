/*!
 * @pixi/assets - v7.0.0-beta.3
 * Compiled Thu, 13 Oct 2022 15:35:43 UTC
 *
 * @pixi/assets is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */import{Texture as y,BaseTexture as P,utils as p,extensions as A,ExtensionType as l,settings as f,SVGResource as C}from"@pixi/core";class X{constructor(t,e=!1){this._loader=t,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=e}add(t){t.forEach(e=>{this._assetList.push(e)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const t=[],e=Math.min(this._assetList.length,this._maxConcurrent);for(let s=0;s<e;s++)t.push(this._assetList.pop());await this._loader.load(t),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(t){this._isActive!==t&&(this._isActive=t,t&&!this._isLoading&&this._next())}}const u=(a,t)=>(Array.isArray(a)||(a=[a]),t?a.map(e=>typeof e=="string"?t(e):e):a);function T(a,t,e,s,r){const i=t[e];for(let n=0;n<i.length;n++){const o=i[n];e<t.length-1?T(a.replace(s[e],o),t,e+1,s,r):r.push(a.replace(s[e],o))}}function O(a){const t=/\{(.*?)\}/g,e=a.match(t),s=[];if(e){const r=[];e.forEach(i=>{const n=i.substring(1,i.length-1).split(",");r.push(n)}),T(a,r,0,e,s)}else s.push(a);return s}const v=a=>!Array.isArray(a);class Z{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(t){return this._cache.has(t)}get(t){return this._cache.get(t)}set(t,e){const s=u(t);let r;for(let o=0;o<this.parsers.length;o++){const h=this.parsers[o];if(h.test(e)){r=h.getCacheableAssets(s,e);break}}r||(r={},s.forEach(o=>{r[o]=e}));const i=Object.keys(r),n={cacheKeys:i,keys:s};if(s.forEach(o=>{this._cacheMap.set(o,n)}),i.forEach(o=>{this._cache.has(o)&&this._cache.get(o),this._cache.set(o,r[o])}),e instanceof y){const o=e;s.forEach(h=>{o.baseTexture!==y.EMPTY.baseTexture&&P.addToCache(o.baseTexture,h),y.addToCache(o,h)})}}remove(t){if(this._cacheMap.get(t),!this._cacheMap.has(t))return;const e=this._cacheMap.get(t);e.cacheKeys.forEach(s=>{this._cache.delete(s)}),e.keys.forEach(s=>{this._cacheMap.delete(s)})}get parsers(){return this._parsers}}const _=new Z;class ${constructor(){this._parsers=[],this.promiseCache={}}reset(){this.promiseCache={}}_getLoadPromiseAndParser(t,e){const s={promise:null,parser:null};return s.promise=(async()=>{let r=null;for(let i=0;i<this.parsers.length;i++){const n=this.parsers[i];if(n.load&&n.test?.(t,e,this)){r=await n.load(t,e,this),s.parser=n;break}}if(!s.parser)return null;for(let i=0;i<this.parsers.length;i++){const n=this.parsers[i];n.parse&&n.parse&&await n.testParse?.(r,e,this)&&(r=await n.parse(r,e,this)||r,s.parser=n)}return r})(),s}async load(t,e){let s=0;const r={},i=v(t),n=u(t,c=>({src:c})),o=n.length,h=n.map(async c=>{const d=p.path.toAbsolute(c.src);if(!r[c.src])try{this.promiseCache[d]||(this.promiseCache[d]=this._getLoadPromiseAndParser(d,c)),r[c.src]=await this.promiseCache[d].promise,e&&e(++s/o)}catch(g){throw delete this.promiseCache[d],delete r[c.src],new Error(`[Loader.load] Failed to load ${d}.
${g}`)}});return await Promise.all(h),i?r[n[0].src]:r}async unload(t){const e=u(t,s=>({src:s})).map(async s=>{const r=p.path.toAbsolute(s.src),i=this.promiseCache[r];if(i){const n=await i.promise;i.parser?.unload?.(n,s,this),delete this.promiseCache[r]}});await Promise.all(e)}get parsers(){return this._parsers}}class K{constructor(){this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}prefer(...t){t.forEach(e=>{this._preferredOrder.push(e),e.priority||(e.priority=Object.keys(e.params))}),this._resolverHash={}}set basePath(t){this._basePath=t}get basePath(){return this._basePath}set rootPath(t){this._rootPath=t}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this._preferredOrder=[],this._resolverHash={},this._assetMap={},this._rootPath=null,this._basePath=null,this._manifest=null}addManifest(t){this._manifest,this._manifest=t,t.bundles.forEach(e=>{this.addBundle(e.name,e.assets)})}addBundle(t,e){const s=[];Array.isArray(e)?e.forEach(r=>{typeof r.name=="string"?s.push(r.name):s.push(...r.name),this.add(r.name,r.srcs)}):Object.keys(e).forEach(r=>{s.push(r),this.add(r,e[r])}),this._bundles[t]=s}add(t,e,s){const r=u(t);r.forEach(n=>{this._assetMap[n]}),Array.isArray(e)||(typeof e=="string"?e=O(e):e=[e]);const i=e.map(n=>{let o=n;if(typeof n=="string"){let h=!1;for(let c=0;c<this._parsers.length;c++){const d=this._parsers[c];if(d.test(n)){o=d.parse(n),h=!0;break}}h||(o={src:n})}return o.format||(o.format=o.src.split(".").pop()),o.alias||(o.alias=r),(this._basePath||this._rootPath)&&(o.src=p.path.toAbsolute(o.src,this._basePath,this._rootPath)),o.data=o.data??s,o});r.forEach(n=>{this._assetMap[n]=i})}resolveBundle(t){const e=v(t);t=u(t);const s={};return t.forEach(r=>{const i=this._bundles[r];i&&(s[r]=this.resolve(i))}),e?s[t[0]]:s}resolveUrl(t){const e=this.resolve(t);if(typeof t!="string"){const s={};for(const r in e)s[r]=e[r].src;return s}return e.src}resolve(t){const e=v(t);t=u(t);const s={};return t.forEach(r=>{if(!this._resolverHash[r])if(this._assetMap[r]){let i=this._assetMap[r];const n=this._getPreferredOrder(i),o=i[0];n?.priority.forEach(h=>{n.params[h].forEach(c=>{const d=i.filter(g=>g[h]?g[h]===c:!1);d.length&&(i=d)})}),this._resolverHash[r]=i[0]??o}else{let i=r;(this._basePath||this._rootPath)&&(i=p.path.toAbsolute(i,this._basePath,this._rootPath)),this._resolverHash[r]={src:i}}s[r]=this._resolverHash[r]}),e?s[t[0]]:s}_getPreferredOrder(t){for(let e=0;e<t.length;e++){const s=t[0],r=this._preferredOrder.find(i=>i.params.format.includes(s.format));if(r)return r}return this._preferredOrder[0]}}class j{constructor(){this._detections=[],this._initialized=!1,this.resolver=new K,this.loader=new $,this.cache=_,this._backgroundLoader=new X(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(t={}){if(this._initialized)return;if(this._initialized=!0,t.basePath&&(this.resolver.basePath=t.basePath),t.manifest){let i=t.manifest;typeof i=="string"&&(i=await this.load(i)),this.resolver.addManifest(i)}const e=t.texturePreference?.resolution??1,s=typeof e=="number"?[e]:e;let r=[];if(t.texturePreference?.format){const i=t.texturePreference?.format;r=typeof i=="string"?[i]:i;for(const n of this._detections)await n.test()||(r=await n.remove(r))}else for(const i of this._detections)await i.test()&&(r=await i.add(r));this.resolver.prefer({params:{format:r,resolution:s}})}add(t,e,s){this.resolver.add(t,e,s)}async load(t,e){this._initialized||await this.init();const s=v(t),r=u(t).map(o=>typeof o!="string"?(this.resolver.add(o.src,o),o.src):o),i=this.resolver.resolve(r),n=await this._mapLoadToResolve(i,e);return s?n[r[0]]:n}addBundle(t,e){this.resolver.addBundle(t,e)}async loadBundle(t,e){this._initialized||await this.init();let s=!1;typeof t=="string"&&(s=!0,t=[t]);const r=this.resolver.resolveBundle(t),i={},n=Object.keys(r);let o=0,h=0;const c=()=>{e?.(++o/h)},d=n.map(g=>{const k=r[g];return h+=Object.keys(k).length,this._mapLoadToResolve(k,c).then(V=>{i[g]=V})});return await Promise.all(d),s?i[t[0]]:i}async backgroundLoad(t){this._initialized||await this.init(),typeof t=="string"&&(t=[t]);const e=this.resolver.resolve(t);this._backgroundLoader.add(Object.values(e))}async backgroundLoadBundle(t){this._initialized||await this.init(),typeof t=="string"&&(t=[t]);const e=this.resolver.resolveBundle(t);Object.values(e).forEach(s=>{this._backgroundLoader.add(Object.values(s))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(t){if(typeof t=="string")return _.get(t);const e={};for(let s=0;s<t.length;s++)e[s]=_.get(t[s]);return e}async _mapLoadToResolve(t,e){const s=Object.values(t),r=Object.keys(t);this._backgroundLoader.active=!1;const i=await this.loader.load(s,e);this._backgroundLoader.active=!0;const n={};return s.forEach((o,h)=>{const c=i[o.src],d=[o.src];o.alias&&d.push(...o.alias),n[r[h]]=c,_.set(d,c)}),n}async unload(t){this._initialized||await this.init();const e=u(t).map(r=>typeof r!="string"?r.src:r),s=this.resolver.resolve(e);await this._unloadFromResolved(s)}async unloadBundle(t){this._initialized||await this.init(),t=u(t);const e=this.resolver.resolveBundle(t),s=Object.keys(e).map(r=>this._unloadFromResolved(e[r]));await Promise.all(s)}async _unloadFromResolved(t){const e=Object.values(t);e.forEach(s=>{_.remove(s.src)}),await this.loader.unload(e)}get detections(){return this._detections}}const w=new j;A.handleByList(l.LoadParser,w.loader.parsers).handleByList(l.ResolveParser,w.resolver.parsers).handleByList(l.CacheParser,w.cache.parsers).handleByList(l.DetectionParser,w.detections);const R={loader:l.LoadParser,resolver:l.ResolveParser,cache:l.CacheParser,detection:l.DetectionParser};A.handle(l.Asset,a=>{const t=a.ref;Object.entries(R).filter(([e])=>!!t[e]).forEach(([e,s])=>A.add(Object.assign(t[e],{extension:t[e].extension??s})))},a=>{const t=a.ref;Object.keys(R).filter(e=>!!t[e]).forEach(e=>A.remove(t[e]))});const M={extension:l.CacheParser,test:a=>Array.isArray(a)&&a.every(t=>t instanceof y),getCacheableAssets:(a,t)=>{const e={};return a.forEach(s=>{t.forEach((r,i)=>{e[s+(i===0?"":i+1)]=r})}),e}};A.add(M);var m=(a=>(a[a.Low=0]="Low",a[a.Normal=1]="Normal",a[a.High=2]="High",a))(m||{});const I={extension:{type:l.LoadParser,priority:m.Low},test(a){return p.path.extname(a).includes(".json")},async load(a){return await(await f.ADAPTER.fetch(a)).json()}};A.add(I);const W={extension:{type:l.LoadParser,priority:m.Low},test(a){return p.path.extname(a).includes(".txt")},async load(a){return await(await f.ADAPTER.fetch(a)).text()}};A.add(W);const q=["normal","bold","100","200","300","400","500","600","700","800","900"],J=["woff","woff2","ttf","otf"];function F(a){const t=p.path.extname(a);return p.path.basename(a,t).replace(/(-|_)/g," ").toLowerCase().split(" ").map(e=>e.charAt(0).toUpperCase()+e.slice(1)).join(" ")}const D={extension:{type:l.LoadParser,priority:m.Low},test(a){const t=a.split("?")[0].split(".").pop();return J.includes(t)},async load(a,t){if(!globalThis.navigator.onLine)throw new Error("[loadWebFont] Cannot load font - navigator is offline");const e=f.ADAPTER.getFontFaceSet();if(e){const s=[],r=t.data?.family??F(a),i=t.data?.weights?.filter(o=>q.includes(o))??["normal"],n=t.data??{};for(let o=0;o<i.length;o++){const h=i[o],c=new FontFace(r,`url(${a})`,{...n,weight:h});await c.load(),e.add(c),s.push(c)}return s.length===1?s[0]:s}return null},unload(a){(Array.isArray(a)?a:[a]).forEach(t=>f.ADAPTER.getFontFaceSet().delete(t))}};A.add(D);let H=0,B;const tt={id:"loadImageBitmap",code:`
    self.onmessage = function(event) {

        async function loadImageBitmap(url)
        {
            const response = await fetch(url);
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);
            return imageBitmap;
        }

        loadImageBitmap(event.data.data[0]).then(imageBitmap => {
            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }).catch(error => {
            self.postMessage({
                data: null,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        });
    }`};let L;class et{constructor(){this._initialized=!1,this._createdWorkers=0,this.workerPool=[],this.queue=[],this.resolveHash={}}loadImageBitmap(t){return this._run("loadImageBitmap",[t])}async _initWorkers(){this._initialized||(this._initialized=!0)}getWorker(){B===void 0&&(B=navigator.hardwareConcurrency||4);let t=this.workerPool.pop();return!t&&this._createdWorkers<B&&(L||(L=URL.createObjectURL(new Blob([tt.code],{type:"application/javascript"}))),this._createdWorkers++,t=new Worker(L),t.addEventListener("message",e=>{this.complete(e.data),this.returnWorker(e.target),this.next()})),t}returnWorker(t){this.workerPool.push(t)}complete(t){const e=t.data;this.resolveHash[t.uuid](e),this.resolveHash[t.uuid]=null}_run(t,e){this._initWorkers();const s=new Promise(r=>{this.queue.push({id:t,arguments:e,resolve:r})});return this.next(),s}next(){if(!this.queue.length)return;const t=this.getWorker();if(!t)return;const e=this.queue.pop(),s=e.id;this.resolveHash[H]=e.resolve,t.postMessage({data:e.arguments,uuid:H++,id:s})}}const st=new et;function z(a,t){const e=a.split("?")[0],s=p.path.extname(e).toLowerCase();return Array.isArray(t)?t.includes(s.toLowerCase()):s.toLowerCase()===t}function x(a,t,e){const s=new y(a);return s.baseTexture.on("dispose",()=>{delete t.promiseCache[e]}),s}const E=[".jpg",".png",".jpeg",".avif",".webp"];async function G(a){const t=await(await f.ADAPTER.fetch(a)).blob();return await createImageBitmap(t)}const b={extension:{type:l.LoadParser,priority:m.High},config:{preferWorkers:!0},test(a){let t=!1;for(let e=0;e<E.length;e++)if(a.indexOf(`data:image/${E[e].slice(1)}`)===0){t=!0;break}return t||z(a,E)},async load(a,t,e){let s=null;globalThis.createImageBitmap?s=this.config.preferWorkers?await st.loadImageBitmap(a):await G(a):s=await new Promise(i=>{s=new Image,s.crossOrigin="anonymous",s.src=a,s.complete?i(s):s.onload=()=>{i(s)}});const r=new P(s,{resolution:p.getResolutionOfUrl(a),...t.data});return r.resource.src=a,x(r,e,a)},unload(a){a.destroy(!0)}};A.add(b);const at={extension:{type:l.LoadParser,priority:m.High},test(a){return p.path.extname(a).includes(".svg")},async testParse(a){return C.test(a)},async parse(a,t,e){const s=new C(a,t?.data?.resourceOptions),r=new P(s,{resolution:p.getResolutionOfUrl(a),...t?.data});r.resource.src=a;const i=x(r,e,a);return t?.data?.resourceOptions?.autoLoad||await s.load(),i},async load(a,t){return(await f.ADAPTER.fetch(a)).text()},unload:b.unload},U={extension:l.ResolveParser,test:b.test,parse:a=>({resolution:parseFloat(f.RETINA_PREFIX.exec(a)?.[1]??"1"),format:a.split(".").pop(),src:a})};A.add(U);const Q={extension:{type:l.DetectionParser,priority:1},test:async()=>{if(!globalThis.createImageBitmap)return!1;const a="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",t=await f.ADAPTER.fetch(a).then(e=>e.blob());return createImageBitmap(t).then(()=>!0,()=>!1)},add:async a=>[...a,"avif"],remove:async a=>a.filter(t=>t!=="avif")};A.add(Q);const Y={extension:{type:l.DetectionParser,priority:0},test:async()=>{if(!globalThis.createImageBitmap)return!1;const a="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",t=await f.ADAPTER.fetch(a).then(e=>e.blob());return createImageBitmap(t).then(()=>!0,()=>!1)},add:async a=>[...a,"webp"],remove:async a=>a.filter(t=>t!=="webp")};A.add(Y);const N=["png","jpg","jpeg"],S={extension:{type:l.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async a=>[...a,...N],remove:async a=>a.filter(t=>!N.includes(t))};A.add(S);export{w as Assets,j as AssetsClass,_ as Cache,m as LoaderParserPriority,M as cacheTextureArray,z as checkExtension,u as convertToList,O as createStringVariations,x as createTexture,Q as detectAvif,S as detectDefaults,Y as detectWebp,F as getFontFamilyName,v as isSingleItem,G as loadImageBitmap,I as loadJson,at as loadSVG,b as loadTextures,W as loadTxt,D as loadWebFont,U as resolveTextureUrl};
//# sourceMappingURL=assets.min.mjs.map
