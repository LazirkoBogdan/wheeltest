{"version":3,"file":"assets.min.mjs","sources":["../../src/BackgroundLoader.ts","../../src/utils/convertToList.ts","../../src/utils/createStringVariations.ts","../../src/utils/isSingleItem.ts","../../src/cache/Cache.ts","../../src/loader/Loader.ts","../../src/resolver/Resolver.ts","../../src/Assets.ts","../../src/AssetExtension.ts","../../src/cache/parsers/cacheTextureArray.ts","../../src/loader/parsers/LoaderParser.ts","../../src/loader/parsers/loadJson.ts","../../src/loader/parsers/loadTxt.ts","../../src/loader/parsers/loadWebFont.ts","../../src/loader/parsers/WorkerManager.ts","../../src/loader/parsers/textures/utils/checkExtension.ts","../../src/loader/parsers/textures/utils/createTexture.ts","../../src/loader/parsers/textures/loadTexture.ts","../../src/loader/parsers/textures/loadSVG.ts","../../src/resolver/parsers/resolveTextureUrl.ts","../../src/detections/parsers/detectAvif.ts","../../src/detections/parsers/detectWebp.ts","../../src/detections/parsers/detectDefaults.ts"],"sourcesContent":["import type { LoadAsset } from './loader';\nimport type { Loader } from './loader/Loader';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof PIXI\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: LoadAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: LoadAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        // eslint-disable-next-line no-console\n        if (this.verbose)console.log('[BackgroundLoader] assets: ', this._assetList);\n\n        if (this._isActive && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            this._next();\n        }\n    }\n\n    /**\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    /** Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset. */\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n}\n","export const convertToList = <T>(input: string | T | (string | T)[], transform?: (input: string) => T): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string')\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","import { utils } from '@pixi/core';\nimport { convertToList, isSingleItem } from '../utils';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser, LoadAsset } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof PIXI\n * @class AssetLoader\n */\nexport class Loader\n{\n    private _parsers: LoaderParser[] = [];\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: LoadAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.load && parser.test?.(url, data, this))\n                {\n                    asset = await parser.load(url, data, this);\n                    result.parser = parser;\n\n                    break;\n                }\n            }\n\n            if (!result.parser)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);\n                // #endif\n\n                return null;\n            }\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads an asset(s) using the parsers added to the Loader.\n     * @example\n     * // single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     * @example\n     * // multiple assets:\n     * const assets = await  Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - a function that gets called when the progress changes\n     */\n    public async load(\n        assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<{[key: string]: any} | any>\n    {\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<LoadAsset>(assetsToLoadIn, (item) => ({\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads an asset(s). Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<LoadAsset>(assetsToUnloadIn, (item) => ({\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                loadPromise.parser?.unload?.(loadedAsset, asset, this);\n\n                delete this.promiseCache[url];\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): LoaderParser[]\n    {\n        return this._parsers;\n    }\n}\n","import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\nimport type { ResolveAsset, PreferOrder, ResolveURLParser, ResolverManifest, ResolverBundle } from './types';\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```\n *  resolver.prefer({\n *      params:{\n *          format:'webp',\n *          resolution: 2,\n *      }\n *  })\n *\n *  resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n *  resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _assetMap: Record<string, ResolveAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolveAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: ResolverManifest;\n    private _bundles: Record<string, string[]> = {};\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *    {\n     *      resolution:2,\n     *      format:'png'\n     *      src: 'image@2x.png'\n     *    },\n     *    {\n     *      resolution:1,\n     *      format:'png'\n     *      src: 'image.png'\n     *    }\n     * ]);\n     *\n     * // with a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *    'image@2x.png'\n     *    'image.png'\n     * ]);\n     * @\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this._preferredOrder = [];\n\n        this._resolverHash = {};\n        this._assetMap = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: ResolverManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     *  resolver.addBundle('animals', {\n     *    bunny: 'bunny.png',\n     *    chicken: 'chicken.png',\n     *    thumper: 'thumper.png',\n     *  });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                if (typeof asset.name === 'string')\n                {\n                    assetNames.push(asset.name);\n                }\n                else\n                {\n                    assetNames.push(...asset.name);\n                }\n\n                this.add(asset.name, asset.srcs);\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                assetNames.push(key);\n                this.add(key, assets[key]);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // single key, single asset:\n     * resolver.add('foo', 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // multiple keys, single asset:\n     * resolver.add(['foo', 'boo'], 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // multiple keys, multiple assets:\n     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // add custom data attached to the resolver\n     * Resolver.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options\n     * );\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => {src: 'bunny.png', data: {scaleMode: SCALE_MODES.NEAREST}}\n     * @param keysIn - The keys to map, can be an array or a single key\n     * @param assetsIn - The assets to associate with the key(s)\n     * @param data - The data that will be attached to the object that resolved object.\n     */\n    public add(keysIn: string | string[], assetsIn: string | ResolveAsset | (ResolveAsset | string)[], data?: unknown): void\n    {\n        const keys: string[] = convertToList<string>(keysIn);\n\n        keys.forEach((key) =>\n        {\n            if (this._assetMap[key])\n            {\n                // #if _DEBUG\n                console.warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        });\n\n        if (!Array.isArray(assetsIn))\n        {\n            if (typeof assetsIn === 'string')\n            {\n                assetsIn = createStringVariations(assetsIn);\n            }\n            else\n            {\n                assetsIn = [assetsIn];\n            }\n        }\n\n        const assetMap: ResolveAsset[] = assetsIn.map((asset): ResolveAsset =>\n        {\n            let formattedAsset = asset as ResolveAsset;\n\n            // check if is a string\n            if (typeof asset === 'string')\n            {\n                // first see if it contains any {} tags...\n\n                let parsed = false;\n\n                for (let i = 0; i < this._parsers.length; i++)\n                {\n                    const parser = this._parsers[i];\n\n                    if (parser.test(asset))\n                    {\n                        formattedAsset = parser.parse(asset);\n                        parsed = true;\n                        break;\n                    }\n                }\n\n                if (!parsed)\n                {\n                    formattedAsset = {\n                        src: asset,\n                    };\n                }\n            }\n\n            if (!formattedAsset.format)\n            {\n                formattedAsset.format = formattedAsset.src.split('.').pop();\n            }\n\n            if (!formattedAsset.alias)\n            {\n                formattedAsset.alias = keys;\n            }\n\n            if (this._basePath || this._rootPath)\n            {\n                formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n            }\n\n            formattedAsset.data = formattedAsset.data ?? data;\n\n            return formattedAsset;\n        });\n\n        keys.forEach((key) =>\n        {\n            this._assetMap[key] = assetMap;\n        });\n    }\n\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // manifest example\n     * const manifest = {\n     *   bundles:[{\n     *      name:'load-screen',\n     *      assets:[\n     *          {\n     *             name: 'background',\n     *             srcs: 'sunset.png',\n     *          },\n     *          {\n     *             name: 'bar',\n     *             srcs: 'load-bar.{png,webp}',\n     *          }\n     *      ]\n     *   },\n     *   {\n     *      name:'game-screen',\n     *      assets:[\n     *          {\n     *             name: 'character',\n     *             srcs: 'robot.png',\n     *          },\n     *          {\n     *             name: 'enemy',\n     *             srcs: 'bad-guy.png',\n     *          }\n     *      ]\n     *   }]\n     * }}\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: string | string[]):\n    Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolveAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                out[bundleId] = this.resolve(assetNames) as Record<string, ResolveAsset>;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: string | string[]): string | Record<string, string>\n    {\n        const result = this.resolve(key);\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolveAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolveAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => {src:'bunny.png'}\n     *\n     * // will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => {src:'another-thing.png'}\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolveAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    const bestAsset = assets[0];\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey])\n                                {\n                                    return asset[priorityKey] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    let src = key;\n\n                    if (this._basePath || this._rootPath)\n                    {\n                        src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n                    }\n\n                    // if the resolver fails we just pass back the key assuming its a url\n                    this._resolverHash[key] = {\n                        src,\n                    };\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolveAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred =  this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n}\n","import { extensions, ExtensionType } from '@pixi/core';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport type { FormatDetectionParser } from './detections';\nimport type {\n    LoadAsset,\n    LoaderParser\n} from './loader';\nimport { Loader } from './loader/Loader';\nimport type { PreferOrder, ResolveAsset, ResolverBundle, ResolverManifest, ResolveURLParser } from './resolver';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Initialization options object for Asset Class.\n * @memberof PIXI\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | ResolverManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /** the formats you prefer, by default this will be:  ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: string | string[];\n    };\n\n    // advanced users can add custom parsers and and preferences for how things are resolved\n    /** loader options to configure the loader with, currently only parsers! */\n    loader?: {\n        /** custom parsers can be added here, for example something that could load a sound or a 3D model */\n        parsers?: LoaderParser[];\n        // more...\n    };\n    /** resolver specific options */\n    resolver?: {\n        /**\n         * a list of urlParsers, these can read the URL and pick put the various options.\n         * for example there is a texture URL parser that picks our resolution and file format.\n         * You can add custom ways to read URLs and extract information here.\n         */\n        urlParsers?: ResolveURLParser[];\n        /**\n         * a list of preferOrders that let the resolver know which asset to pick.\n         * already built-in we have a texture preferOrders that let the resolve know which asset to prefer\n         * if it has multiple assets to pick from (resolution/formats etc)\n         */\n        preferOrders?: PreferOrder[];\n    };\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @memberof PIXI\n * @namespace Assets\n *\n * Only one Asset Class exists accessed via the Global Asset object.\n *\n * It has four main responsibilities:\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4: Allow developers to unload assets and clear the cache.\n *\n * It also has a few advanced features:\n * 1. Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n *\n *\n * Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once.\n *\n * for example:\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * //promise1 === promise2\n * ```\n * here both promises will be the same. Once resolved.. forever resolved! It makes for really easy resource management!\n *\n * Out of the box it supports the following files:\n * * textures (avif, webp, png, jpg, gif)\n * * sprite sheets (json)\n * * bitmap fonts (xml, fnt, txt)\n * * web fonts (ttf, woff, woff2)\n * * json files (json)\n * * text files (txt)\n *\n * More types can be added fairly easily by creating additional loader parsers.\n *\n * ### Textures\n * - Textures are loaded as ImageBitmap on a worker thread where possible.\n * Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images\n *  but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)\n * #### Sprite sheets\n * - it's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name:\n *\n * `my-spritesheet{resolution}.{imageFormat}.json`\n *\n * for example:\n *\n * `my-spritesheet@2x.webp.json` // 2x resolution, WebP sprite sheet\n * `my-spritesheet@0.5x.png.json` // 0.5x resolution, png sprite sheet\n *\n * This is optional! you can just load a sprite sheet as normal,\n * This is only useful if you have a bunch of different res / formatted spritesheets\n *\n * ### Fonts\n * * Web fonts will be loaded with all weights.\n * it is possible to load only specific weights by doing the following:\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * // load specific weights..\n * await Assets.load({\n *    data: {\n *      weights: ['normal'], // only loads the weight\n *    },\n *    src: `outfit.woff2`,\n * });\n *\n * // load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * ### Background Loading\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n *\n * ### Manifest and Bundles\n * - Manifest is a JSON file that contains a list of all assets and their properties.\n * - Bundles are a way to group assets together.\n *\n * ```\n * import { Assets } from 'pixi.js';\n *\n * // manifest example\n * const manifest = {\n *   bundles:[{\n *      name:'load-screen',\n *      assets:[\n *          {\n *             name: 'background',\n *             srcs: 'sunset.png',\n *          },\n *          {\n *             name: 'bar',\n *             srcs: 'load-bar.{png,webp}',\n *          }\n *      ]\n *   },\n *   {\n *      name:'game-screen',\n *      assets:[\n *          {\n *             name: 'character',\n *             srcs: 'robot.png',\n *          },\n *          {\n *             name: 'enemy',\n *             srcs: 'bad-guy.png',\n *          }\n *      ]\n *   }]\n * }}\n *\n * await Asset.init({\n *  manifest\n * });\n *\n * // load a bundle..\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // load another..\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /**\n     * The loader, loads stuff!\n     * @type {PIXI.AssetLoader}\n     */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {PIXI.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Asset manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            console.warn('[Assets]AssetManager already initialized, did you load before calling this Asset.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<ResolverManifest>(manifest) as ResolverManifest;\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref =  options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        let formats: string[] = [];\n\n        if (options.texturePreference?.format)\n        {\n            const formatPref = options.texturePreference?.format;\n\n            formats = (typeof formatPref === 'string') ? [formatPref] : formatPref;\n\n            // we should remove any formats that are not supported by the browser\n            for (const detection of this._detections)\n            {\n                if (!await detection.test())\n                {\n                    formats = await detection.remove(formats);\n                }\n            }\n        }\n        else\n        {\n            // we should add any formats that are supported by the browser\n            for (const detection of this._detections)\n            {\n                if (await detection.test())\n                {\n                    formats = await detection.add(formats);\n                }\n            }\n        }\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // simple\n     * Assets.add('bunnyBooBoo', 'bunny.png');\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // multiple keys:\n     * Assets.add(['burger', 'chicken'], 'bunny.png');\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options\n     * );\n     *\n     * // multiple assets,\n     *\n     * // the following all do the same thing:\n     *\n     * Assets.add('bunnyBooBoo', 'bunny{png,webp}');\n     *\n     * Assets.add('bunnyBooBoo', [\n     * 'bunny.png',\n     * 'bunny.webp'\n     * ]);\n     *\n     * Assets.add('bunnyBooBoo', [\n     *    {\n     *       format:'png',\n     *       src:'bunny.png',\n     *    },\n     *    {\n     *       format:'webp',\n     *       src:'bunny.webp',\n     *    }\n     * ]);\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // will try to load WebP if available\n     * @param keysIn - the key or keys that you will reference when loading this asset\n     * @param assetsIn - the asset or assets that will be chosen from when loading via the specified key\n     * @param data - asset-specific data that will be passed to the loaders\n     * - Useful if you want to initiate loaded objects with specific data\n     */\n    public add(keysIn: string | string[], assetsIn: string | (ResolveAsset | string)[], data?: unknown): void\n    {\n        this.resolver.add(keysIn, assetsIn, data);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T=any>(\n        urls: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray = convertToList<ResolveAsset>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    this.resolver.add(url.src as string, url);\n\n                    return url.src;\n                }\n\n                return url;\n            });\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     *  PIXI.Assets.addBundle('animals', {\n     *    bunny: 'bunny.png',\n     *    chicken: 'chicken.png',\n     *    thumper: 'thumper.png',\n     *  });\n     *\n     * const assets = await PIXI.Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * // manifest example\n     * const manifest = {\n     *   bundles:[{\n     *      name:'load-screen',\n     *      assets:[\n     *          {\n     *             name: 'background',\n     *             srcs: 'sunset.png',\n     *          },\n     *          {\n     *             name: 'bar',\n     *             srcs: 'load-bar.{png,webp}',\n     *          }\n     *      ]\n     *   },\n     *   {\n     *      name:'game-screen',\n     *      assets:[\n     *          {\n     *             name: 'character',\n     *             srcs: 'robot.png',\n     *          },\n     *          {\n     *             name: 'enemy',\n     *             srcs: 'bad-guy.png',\n     *          }\n     *      ]\n     *   }]\n     * }}\n     *\n     * await Asset.init({\n     *  manifest\n     * });\n     *\n     * // load a bundle..\n     * loadScreenAssets = await PIXI.Assets.loadBundle('load-screen');\n     * // load another..\n     * gameScreenAssets = await PIXI.Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: string | string[], onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. it will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * PIXI.Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await PIXI.Assets.loadBundle('bunny.png'); // will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * await PIXI.Assets.init({\n     *    manifest: {\n     *       bundles: [\n     *       {\n     *          name:'load-screen',\n     *          assets:[...]\n     *       }\n     *       ...]\n     *   }\n     * });\n     *\n     * PIXI.Assets.backgroundLoadBundle('load-screen');\n     *\n     * // later on in your app...\n     * await PIXI.Assets.loadBundle('load-screen'); // will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `PIXI.Assets.load` instead.\n     * (remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T=any>(keys: string | string[]): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolveAsset | Record<string, ResolveAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = Object.values(resolveResults);\n        const resolveKeys = Object.keys(resolveResults);\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult, i) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            out[resolveKeys[i]] = asset;\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * * it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * myImageTexture <-- will now be destroyed.\n     *\n     * // unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: string | string[] | LoadAsset | LoadAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | LoadAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * PIXI.Assets.addBundle({\n     *   'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await PIXI.Assets.loadBundle('thumper');\n     *\n     * // now to unload..\n     *\n     * await await PIXI.Assets.unloadBundle('thumper');\n     *\n     * // all assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolveAsset | Record<string, ResolveAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\n","import { extensions, ExtensionType } from '@pixi/core';\nimport type { LoaderParser } from './loader';\nimport type { CacheParser } from './cache';\nimport type { FormatDetectionParser } from './detections';\nimport type { ResolveURLParser } from './resolver';\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @memberof PIXI\n */\ninterface AssetExtension<ASSET = any, META_DATA = any>\n{\n    extension: ExtensionType.Asset,\n    loader?: Partial<LoaderParser<ASSET, META_DATA>>,\n    resolver?: Partial<ResolveURLParser>,\n    cache?: Partial<CacheParser<ASSET>>,\n    detection?: Partial<FormatDetectionParser>,\n}\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n\nexport type { AssetExtension };\n","import { extensions, ExtensionType, Texture } from '@pixi/core';\nimport type { CacheParser } from '../CacheParser';\n\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: ExtensionType.CacheParser,\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n\nextensions.add(cacheTextureArray);\n","import type { ExtensionMetadata } from '@pixi/core';\nimport type { Loader } from '../Loader';\nimport type { LoadAsset } from '../types';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension\n * test. The higher priority parsers will be checked first.\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * All functions are optional here. The flow:\n *\n * for every asset,\n *\n * 1. `parser.test()`: Test the asset url.\n * 2. `parser.load()`: If test passes call the load function with the url\n * 3. `parser.testParse()`: Test to see if the asset should be parsed by the plugin\n * 4. `parse.parse()`: If test is parsed, then run the parse function on the asset.\n *\n * some plugins may only be used for parsing,\n * some only for loading\n * and some for both!\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any>\n{\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: Record<string, any>\n    /**\n     * each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful than\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => void;\n}\n","import { settings, utils, extensions, ExtensionType } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\n/** simple loader plugin for loading json data */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.json'));\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} as LoaderParser;\n\nextensions.add(loadJson);\n","import { settings, utils, extensions, ExtensionType } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\n/** Simple loader plugin for loading text data */\nexport const loadTxt = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.txt'));\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} as LoaderParser;\n\nextensions.add(loadTxt);\n","import { extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoadAsset } from '../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = ['normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFonts = ['woff', 'woff2', 'ttf', 'otf'];\n\nexport type LoadFontData = {\n    family: string;\n    display: string;\n    featureSettings: string;\n    stretch: string;\n    style: string;\n    unicodeRange: string;\n    variant: string;\n    weights: string[];\n};\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/tital-one.woff' turns into 'Titan One'\n * @param url - File url\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = utils.path.extname(url);\n    const name = utils.path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTitleCase = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(' ');\n\n    return nameTitleCase;\n}\n\n/** Web font loader plugin */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        const tempURL = url.split('?')[0];\n        const extension = tempURL.split('.').pop();\n\n        return validFonts.includes(extension);\n    },\n\n    async load(url: string, options?: LoadAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        // Prevent loading font if navigator is not online\n        if (!globalThis.navigator.onLine)\n        {\n            throw new Error('[loadWebFont] Cannot load font - navigator is offline');\n        }\n\n        const fonts = settings.ADAPTER.getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${url})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        console.warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));\n    }\n} as LoaderParser<FontFace | FontFace[]>;\n\nextensions.add(loadWebFont);\n","let UUID = 0;\nlet MAX_WORKERS: number;\n\nconst workerCode = {\n    id: 'loadImageBitmap',\n    code: `\n    self.onmessage = function(event) {\n\n        async function loadImageBitmap(url)\n        {\n            const response = await fetch(url);\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n            return imageBitmap;\n        }\n\n        loadImageBitmap(event.data.data[0]).then(imageBitmap => {\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }).catch(error => {\n            self.postMessage({\n                data: null,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        });\n    }`,\n};\n\nlet workerURL: string;\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private resolveHash: {[key: string]: (...param: any[]) => void};\n    private readonly workerPool: Worker[];\n    private readonly queue: { id: string; arguments: any[]; resolve: (...param: any[]) => void }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n\n    constructor()\n    {\n        this.workerPool = [];\n        this.queue = [];\n\n        this.resolveHash = {};\n    }\n\n    public loadImageBitmap(src: string): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this.workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            if (!workerURL)\n            {\n                workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: 'application/javascript' }));\n            }\n\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new Worker(workerURL);\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this.complete(event.data);\n\n                this.returnWorker(event.target as Worker);\n                this.next();\n            });\n        }\n\n        return worker;\n    }\n\n    private returnWorker(worker: Worker)\n    {\n        this.workerPool.push(worker);\n    }\n\n    private complete(data: any): void\n    {\n        const result = data.data;\n\n        this.resolveHash[data.uuid](result);\n\n        this.resolveHash[data.uuid] = null;\n    }\n\n    private _run(id: string, args: any[]): Promise<any>\n    {\n        this._initWorkers();\n        // push into the queue...\n\n        const promise =  new Promise((resolve) =>\n        {\n            this.queue.push({ id, arguments: args, resolve });\n        });\n\n        this.next();\n\n        return promise;\n    }\n\n    private next(): void\n    {\n        // nothing to do\n        if (!this.queue.length) return;\n\n        const worker = this.getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this.queue.pop();\n\n        const id = toDo.id;\n\n        this.resolveHash[UUID] = toDo.resolve;\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n","import { utils } from '@pixi/core';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = utils.path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext.toLowerCase());\n    }\n\n    return ext.toLowerCase() === extension;\n}\n","import type { BaseTexture } from '@pixi/core';\nimport { Texture } from '@pixi/core';\nimport type { Loader } from '../../../Loader';\n\nexport function createTexture(base: BaseTexture, loader: Loader, url: string)\n{\n    const texture = new Texture(base);\n\n    // make sure to nuke the promise if a texture is destroyed..\n    texture.baseTexture.on('dispose', () =>\n    {\n        delete loader.promiseCache[url];\n    });\n\n    return texture;\n}\n","import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { checkExtension } from './utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImages = ['.jpg', '.png', '.jpeg', '.avif', '.webp'];\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n */\nexport const loadTextures = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n    },\n\n    test(url: string): boolean\n    {\n        let isValidBase64Suffix = false;\n\n        for (let i = 0; i < validImages.length; i++)\n        {\n            if (url.indexOf(`data:image/${validImages[i].slice(1)}`) === 0)\n            {\n                isValidBase64Suffix = true;\n                break;\n            }\n        }\n\n        return isValidBase64Suffix || checkExtension(url, validImages);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap)\n        {\n            src = this.config.preferWorkers ? await WorkerManager.loadImageBitmap(url) : await loadImageBitmap(url);\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = 'anonymous';\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions>;\n\nextensions.add(loadTextures);\n","import { settings, utils, BaseTexture, ExtensionType, SVGResource } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { loadTextures } from './loadTexture';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\n/** Loads SVG's into Textures */\nexport const loadSVG = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    test(url: string): boolean\n    {\n        return (utils.path.extname(url).includes('.svg'));\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return SVGResource.test(data);\n    },\n\n    async parse(asset: string, data: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        const src = new SVGResource(asset, data?.data?.resourceOptions);\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(asset),\n            ...data?.data,\n        });\n\n        base.resource.src = asset;\n\n        const texture = createTexture(base, loader, asset);\n\n        if (!data?.data?.resourceOptions?.autoLoad)\n        {\n            await src.load();\n        }\n\n        return texture;\n    },\n\n    async load(url: string, _options: LoadAsset): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        return response.text();\n    },\n\n    unload: loadTextures.unload,\n\n} as LoaderParser<Texture | string, IBaseTextureOptions>;\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport { loadTextures } from '../../loader';\n\nimport type { ResolveAsset, ResolveURLParser } from '../types';\n\nexport const resolveTextureUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: loadTextures.test,\n    parse: (value: string): ResolveAsset =>\n        ({\n            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} as ResolveURLParser;\n\nextensions.add(resolveTextureUrl);\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        // eslint-disable-next-line max-len\n        const avifData = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=';\n        const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n\nextensions.add(detectAvif);\n","import { settings, extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        const webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n\nextensions.add(detectWebp);\n","import { extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n\nextensions.add(detectDefaults);\n"],"names":["g","p","h","o","c","l","f","d","P","n","R","m","v","t","a","x","e","s","F","i","u","r"],"mappings":"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"}