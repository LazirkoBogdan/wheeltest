"use strict";/*!
 * @pixi/assets - v7.0.0-beta.3
 * Compiled Thu, 13 Oct 2022 15:35:43 UTC
 *
 * @pixi/assets is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */Object.defineProperty(exports,"__esModule",{value:!0});var o=require("@pixi/core");class U{constructor(e,t=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=t}add(e){e.forEach(t=>{this._assetList.push(t)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],t=Math.min(this._assetList.length,this._maxConcurrent);for(let s=0;s<t;s++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}const A=(a,e)=>(Array.isArray(a)||(a=[a]),e?a.map(t=>typeof t=="string"?e(t):t):a);function P(a,e,t,s,r){const i=e[t];for(let c=0;c<i.length;c++){const n=i[c];t<e.length-1?P(a.replace(s[t],n),e,t+1,s,r):r.push(a.replace(s[t],n))}}function E(a){const e=/\{(.*?)\}/g,t=a.match(e),s=[];if(t){const r=[];t.forEach(i=>{const c=i.substring(1,i.length-1).split(",");r.push(c)}),P(a,r,0,t,s)}else s.push(a);return s}const g=a=>!Array.isArray(a);class S{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(e){return this._cache.has(e)}get(e){return this._cache.get(e)}set(e,t){const s=A(e);let r;for(let n=0;n<this.parsers.length;n++){const l=this.parsers[n];if(l.test(t)){r=l.getCacheableAssets(s,t);break}}r||(r={},s.forEach(n=>{r[n]=t}));const i=Object.keys(r),c={cacheKeys:i,keys:s};if(s.forEach(n=>{this._cacheMap.set(n,c)}),i.forEach(n=>{this._cache.has(n)&&this._cache.get(n),this._cache.set(n,r[n])}),t instanceof o.Texture){const n=t;s.forEach(l=>{n.baseTexture!==o.Texture.EMPTY.baseTexture&&o.BaseTexture.addToCache(n.baseTexture,l),o.Texture.addToCache(n,l)})}}remove(e){if(this._cacheMap.get(e),!this._cacheMap.has(e))return;const t=this._cacheMap.get(e);t.cacheKeys.forEach(s=>{this._cache.delete(s)}),t.keys.forEach(s=>{this._cacheMap.delete(s)})}get parsers(){return this._parsers}}const f=new S;class Q{constructor(){this._parsers=[],this.promiseCache={}}reset(){this.promiseCache={}}_getLoadPromiseAndParser(e,t){const s={promise:null,parser:null};return s.promise=(async()=>{let r=null;for(let i=0;i<this.parsers.length;i++){const c=this.parsers[i];if(c.load&&c.test?.(e,t,this)){r=await c.load(e,t,this),s.parser=c;break}}if(!s.parser)return null;for(let i=0;i<this.parsers.length;i++){const c=this.parsers[i];c.parse&&c.parse&&await c.testParse?.(r,t,this)&&(r=await c.parse(r,t,this)||r,s.parser=c)}return r})(),s}async load(e,t){let s=0;const r={},i=g(e),c=A(e,h=>({src:h})),n=c.length,l=c.map(async h=>{const d=o.utils.path.toAbsolute(h.src);if(!r[h.src])try{this.promiseCache[d]||(this.promiseCache[d]=this._getLoadPromiseAndParser(d,h)),r[h.src]=await this.promiseCache[d].promise,t&&t(++s/n)}catch(u){throw delete this.promiseCache[d],delete r[h.src],new Error(`[Loader.load] Failed to load ${d}.
${u}`)}});return await Promise.all(l),i?r[c[0].src]:r}async unload(e){const t=A(e,s=>({src:s})).map(async s=>{const r=o.utils.path.toAbsolute(s.src),i=this.promiseCache[r];if(i){const c=await i.promise;i.parser?.unload?.(c,s,this),delete this.promiseCache[r]}});await Promise.all(t)}get parsers(){return this._parsers}}class V{constructor(){this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}prefer(...e){e.forEach(t=>{this._preferredOrder.push(t),t.priority||(t.priority=Object.keys(t.params))}),this._resolverHash={}}set basePath(e){this._basePath=e}get basePath(){return this._basePath}set rootPath(e){this._rootPath=e}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this._preferredOrder=[],this._resolverHash={},this._assetMap={},this._rootPath=null,this._basePath=null,this._manifest=null}addManifest(e){this._manifest,this._manifest=e,e.bundles.forEach(t=>{this.addBundle(t.name,t.assets)})}addBundle(e,t){const s=[];Array.isArray(t)?t.forEach(r=>{typeof r.name=="string"?s.push(r.name):s.push(...r.name),this.add(r.name,r.srcs)}):Object.keys(t).forEach(r=>{s.push(r),this.add(r,t[r])}),this._bundles[e]=s}add(e,t,s){const r=A(e);r.forEach(c=>{this._assetMap[c]}),Array.isArray(t)||(typeof t=="string"?t=E(t):t=[t]);const i=t.map(c=>{let n=c;if(typeof c=="string"){let l=!1;for(let h=0;h<this._parsers.length;h++){const d=this._parsers[h];if(d.test(c)){n=d.parse(c),l=!0;break}}l||(n={src:c})}return n.format||(n.format=n.src.split(".").pop()),n.alias||(n.alias=r),(this._basePath||this._rootPath)&&(n.src=o.utils.path.toAbsolute(n.src,this._basePath,this._rootPath)),n.data=n.data??s,n});r.forEach(c=>{this._assetMap[c]=i})}resolveBundle(e){const t=g(e);e=A(e);const s={};return e.forEach(r=>{const i=this._bundles[r];i&&(s[r]=this.resolve(i))}),t?s[e[0]]:s}resolveUrl(e){const t=this.resolve(e);if(typeof e!="string"){const s={};for(const r in t)s[r]=t[r].src;return s}return t.src}resolve(e){const t=g(e);e=A(e);const s={};return e.forEach(r=>{if(!this._resolverHash[r])if(this._assetMap[r]){let i=this._assetMap[r];const c=this._getPreferredOrder(i),n=i[0];c?.priority.forEach(l=>{c.params[l].forEach(h=>{const d=i.filter(u=>u[l]?u[l]===h:!1);d.length&&(i=d)})}),this._resolverHash[r]=i[0]??n}else{let i=r;(this._basePath||this._rootPath)&&(i=o.utils.path.toAbsolute(i,this._basePath,this._rootPath)),this._resolverHash[r]={src:i}}s[r]=this._resolverHash[r]}),t?s[e[0]]:s}_getPreferredOrder(e){for(let t=0;t<e.length;t++){const s=e[0],r=this._preferredOrder.find(i=>i.params.format.includes(s.format));if(r)return r}return this._preferredOrder[0]}}class B{constructor(){this._detections=[],this._initialized=!1,this.resolver=new V,this.loader=new Q,this.cache=f,this._backgroundLoader=new U(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){if(this._initialized)return;if(this._initialized=!0,e.basePath&&(this.resolver.basePath=e.basePath),e.manifest){let i=e.manifest;typeof i=="string"&&(i=await this.load(i)),this.resolver.addManifest(i)}const t=e.texturePreference?.resolution??1,s=typeof t=="number"?[t]:t;let r=[];if(e.texturePreference?.format){const i=e.texturePreference?.format;r=typeof i=="string"?[i]:i;for(const c of this._detections)await c.test()||(r=await c.remove(r))}else for(const i of this._detections)await i.test()&&(r=await i.add(r));this.resolver.prefer({params:{format:r,resolution:s}})}add(e,t,s){this.resolver.add(e,t,s)}async load(e,t){this._initialized||await this.init();const s=g(e),r=A(e).map(n=>typeof n!="string"?(this.resolver.add(n.src,n),n.src):n),i=this.resolver.resolve(r),c=await this._mapLoadToResolve(i,t);return s?c[r[0]]:c}addBundle(e,t){this.resolver.addBundle(e,t)}async loadBundle(e,t){this._initialized||await this.init();let s=!1;typeof e=="string"&&(s=!0,e=[e]);const r=this.resolver.resolveBundle(e),i={},c=Object.keys(r);let n=0,l=0;const h=()=>{t?.(++n/l)},d=c.map(u=>{const w=r[u];return l+=Object.keys(w).length,this._mapLoadToResolve(w,h).then(z=>{i[u]=z})});return await Promise.all(d),s?i[e[0]]:i}async backgroundLoad(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(t))}async backgroundLoadBundle(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolveBundle(e);Object.values(t).forEach(s=>{this._backgroundLoader.add(Object.values(s))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if(typeof e=="string")return f.get(e);const t={};for(let s=0;s<e.length;s++)t[s]=f.get(e[s]);return t}async _mapLoadToResolve(e,t){const s=Object.values(e),r=Object.keys(e);this._backgroundLoader.active=!1;const i=await this.loader.load(s,t);this._backgroundLoader.active=!0;const c={};return s.forEach((n,l)=>{const h=i[n.src],d=[n.src];n.alias&&d.push(...n.alias),c[r[l]]=h,f.set(d,h)}),c}async unload(e){this._initialized||await this.init();const t=A(e).map(r=>typeof r!="string"?r.src:r),s=this.resolver.resolve(t);await this._unloadFromResolved(s)}async unloadBundle(e){this._initialized||await this.init(),e=A(e);const t=this.resolver.resolveBundle(e),s=Object.keys(t).map(r=>this._unloadFromResolved(t[r]));await Promise.all(s)}async _unloadFromResolved(e){const t=Object.values(e);t.forEach(s=>{f.remove(s.src)}),await this.loader.unload(t)}get detections(){return this._detections}}const m=new B;o.extensions.handleByList(o.ExtensionType.LoadParser,m.loader.parsers).handleByList(o.ExtensionType.ResolveParser,m.resolver.parsers).handleByList(o.ExtensionType.CacheParser,m.cache.parsers).handleByList(o.ExtensionType.DetectionParser,m.detections);const T={loader:o.ExtensionType.LoadParser,resolver:o.ExtensionType.ResolveParser,cache:o.ExtensionType.CacheParser,detection:o.ExtensionType.DetectionParser};o.extensions.handle(o.ExtensionType.Asset,a=>{const e=a.ref;Object.entries(T).filter(([t])=>!!e[t]).forEach(([t,s])=>o.extensions.add(Object.assign(e[t],{extension:e[t].extension??s})))},a=>{const e=a.ref;Object.keys(T).filter(t=>!!e[t]).forEach(t=>o.extensions.remove(e[t]))});const L={extension:o.ExtensionType.CacheParser,test:a=>Array.isArray(a)&&a.every(e=>e instanceof o.Texture),getCacheableAssets:(a,e)=>{const t={};return a.forEach(s=>{e.forEach((r,i)=>{t[s+(i===0?"":i+1)]=r})}),t}};o.extensions.add(L);var p=(a=>(a[a.Low=0]="Low",a[a.Normal=1]="Normal",a[a.High=2]="High",a))(p||{});const k={extension:{type:o.ExtensionType.LoadParser,priority:p.Low},test(a){return o.utils.path.extname(a).includes(".json")},async load(a){return await(await o.settings.ADAPTER.fetch(a)).json()}};o.extensions.add(k);const C={extension:{type:o.ExtensionType.LoadParser,priority:p.Low},test(a){return o.utils.path.extname(a).includes(".txt")},async load(a){return await(await o.settings.ADAPTER.fetch(a)).text()}};o.extensions.add(C);const N=["normal","bold","100","200","300","400","500","600","700","800","900"],Y=["woff","woff2","ttf","otf"];function O(a){const e=o.utils.path.extname(a);return o.utils.path.basename(a,e).replace(/(-|_)/g," ").toLowerCase().split(" ").map(t=>t.charAt(0).toUpperCase()+t.slice(1)).join(" ")}const j={extension:{type:o.ExtensionType.LoadParser,priority:p.Low},test(a){const e=a.split("?")[0].split(".").pop();return Y.includes(e)},async load(a,e){if(!globalThis.navigator.onLine)throw new Error("[loadWebFont] Cannot load font - navigator is offline");const t=o.settings.ADAPTER.getFontFaceSet();if(t){const s=[],r=e.data?.family??O(a),i=e.data?.weights?.filter(n=>N.includes(n))??["normal"],c=e.data??{};for(let n=0;n<i.length;n++){const l=i[n],h=new FontFace(r,`url(${a})`,{...c,weight:l});await h.load(),t.add(h),s.push(h)}return s.length===1?s[0]:s}return null},unload(a){(Array.isArray(a)?a:[a]).forEach(e=>o.settings.ADAPTER.getFontFaceSet().delete(e))}};o.extensions.add(j);let R=0,_;const X={id:"loadImageBitmap",code:`
    self.onmessage = function(event) {

        async function loadImageBitmap(url)
        {
            const response = await fetch(url);
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);
            return imageBitmap;
        }

        loadImageBitmap(event.data.data[0]).then(imageBitmap => {
            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }).catch(error => {
            self.postMessage({
                data: null,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        });
    }`};let v;class Z{constructor(){this._initialized=!1,this._createdWorkers=0,this.workerPool=[],this.queue=[],this.resolveHash={}}loadImageBitmap(e){return this._run("loadImageBitmap",[e])}async _initWorkers(){this._initialized||(this._initialized=!0)}getWorker(){_===void 0&&(_=navigator.hardwareConcurrency||4);let e=this.workerPool.pop();return!e&&this._createdWorkers<_&&(v||(v=URL.createObjectURL(new Blob([X.code],{type:"application/javascript"}))),this._createdWorkers++,e=new Worker(v),e.addEventListener("message",t=>{this.complete(t.data),this.returnWorker(t.target),this.next()})),e}returnWorker(e){this.workerPool.push(e)}complete(e){const t=e.data;this.resolveHash[e.uuid](t),this.resolveHash[e.uuid]=null}_run(e,t){this._initWorkers();const s=new Promise(r=>{this.queue.push({id:e,arguments:t,resolve:r})});return this.next(),s}next(){if(!this.queue.length)return;const e=this.getWorker();if(!e)return;const t=this.queue.pop(),s=t.id;this.resolveHash[R]=t.resolve,e.postMessage({data:t.arguments,uuid:R++,id:s})}}const $=new Z;function I(a,e){const t=a.split("?")[0],s=o.utils.path.extname(t).toLowerCase();return Array.isArray(e)?e.includes(s.toLowerCase()):s.toLowerCase()===e}function x(a,e,t){const s=new o.Texture(a);return s.baseTexture.on("dispose",()=>{delete e.promiseCache[t]}),s}const b=[".jpg",".png",".jpeg",".avif",".webp"];async function M(a){const e=await(await o.settings.ADAPTER.fetch(a)).blob();return await createImageBitmap(e)}const y={extension:{type:o.ExtensionType.LoadParser,priority:p.High},config:{preferWorkers:!0},test(a){let e=!1;for(let t=0;t<b.length;t++)if(a.indexOf(`data:image/${b[t].slice(1)}`)===0){e=!0;break}return e||I(a,b)},async load(a,e,t){let s=null;globalThis.createImageBitmap?s=this.config.preferWorkers?await $.loadImageBitmap(a):await M(a):s=await new Promise(i=>{s=new Image,s.crossOrigin="anonymous",s.src=a,s.complete?i(s):s.onload=()=>{i(s)}});const r=new o.BaseTexture(s,{resolution:o.utils.getResolutionOfUrl(a),...e.data});return r.resource.src=a,x(r,t,a)},unload(a){a.destroy(!0)}};o.extensions.add(y);const q={extension:{type:o.ExtensionType.LoadParser,priority:p.High},test(a){return o.utils.path.extname(a).includes(".svg")},async testParse(a){return o.SVGResource.test(a)},async parse(a,e,t){const s=new o.SVGResource(a,e?.data?.resourceOptions),r=new o.BaseTexture(s,{resolution:o.utils.getResolutionOfUrl(a),...e?.data});r.resource.src=a;const i=x(r,t,a);return e?.data?.resourceOptions?.autoLoad||await s.load(),i},async load(a,e){return(await o.settings.ADAPTER.fetch(a)).text()},unload:y.unload},W={extension:o.ExtensionType.ResolveParser,test:y.test,parse:a=>({resolution:parseFloat(o.settings.RETINA_PREFIX.exec(a)?.[1]??"1"),format:a.split(".").pop(),src:a})};o.extensions.add(W);const F={extension:{type:o.ExtensionType.DetectionParser,priority:1},test:async()=>{if(!globalThis.createImageBitmap)return!1;const a="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",e=await o.settings.ADAPTER.fetch(a).then(t=>t.blob());return createImageBitmap(e).then(()=>!0,()=>!1)},add:async a=>[...a,"avif"],remove:async a=>a.filter(e=>e!=="avif")};o.extensions.add(F);const D={extension:{type:o.ExtensionType.DetectionParser,priority:0},test:async()=>{if(!globalThis.createImageBitmap)return!1;const a="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",e=await o.settings.ADAPTER.fetch(a).then(t=>t.blob());return createImageBitmap(e).then(()=>!0,()=>!1)},add:async a=>[...a,"webp"],remove:async a=>a.filter(e=>e!=="webp")};o.extensions.add(D);const H=["png","jpg","jpeg"],G={extension:{type:o.ExtensionType.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async a=>[...a,...H],remove:async a=>a.filter(e=>!H.includes(e))};o.extensions.add(G),exports.Assets=m,exports.AssetsClass=B,exports.Cache=f,exports.LoaderParserPriority=p,exports.cacheTextureArray=L,exports.checkExtension=I,exports.convertToList=A,exports.createStringVariations=E,exports.createTexture=x,exports.detectAvif=F,exports.detectDefaults=G,exports.detectWebp=D,exports.getFontFamilyName=O,exports.isSingleItem=g,exports.loadImageBitmap=M,exports.loadJson=k,exports.loadSVG=q,exports.loadTextures=y,exports.loadTxt=C,exports.loadWebFont=j,exports.resolveTextureUrl=W;
//# sourceMappingURL=assets.min.js.map
