/// <reference types="css-font-loading-module" />

import type { BaseTexture } from '@pixi/core';
import type { ExtensionMetadata } from '@pixi/core';
import { ExtensionType } from '@pixi/core';
import type { IBaseTextureOptions } from '@pixi/core';
import { Resource } from '@pixi/core';
import { Texture } from '@pixi/core';

/**
 * This developer convenience object allows developers to group
 * together the various asset parsers into a single object.
 * @memberof PIXI
 */
export declare interface AssetExtension<ASSET = any, META_DATA = any> {
    extension: ExtensionType.Asset;
    loader?: Partial<LoaderParser<ASSET, META_DATA>>;
    resolver?: Partial<ResolveURLParser>;
    cache?: Partial<CacheParser<ASSET>>;
    detection?: Partial<FormatDetectionParser>;
}

/**
 * Initialization options object for Asset Class.
 * @memberof PIXI
 */
export declare interface AssetInitOptions {
    /** a base path for any assets loaded */
    basePath?: string;
    /**
     * a manifest to tell the asset loader upfront what all your assets are
     * this can be the manifest object itself, or a URL to the manifest.
     */
    manifest?: string | ResolverManifest;
    /**
     * optional preferences for which textures preferences you have when resolving assets
     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone
     * or you might set the resolution to 2 if the user is on a retina display
     */
    texturePreference?: {
        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */
        resolution?: number | number[];
        /** the formats you prefer, by default this will be:  ['avif', 'webp', 'png', 'jpg', 'jpeg'] */
        format?: string | string[];
    };
    /** loader options to configure the loader with, currently only parsers! */
    loader?: {
        /** custom parsers can be added here, for example something that could load a sound or a 3D model */
        parsers?: LoaderParser[];
    };
    /** resolver specific options */
    resolver?: {
        /**
         * a list of urlParsers, these can read the URL and pick put the various options.
         * for example there is a texture URL parser that picks our resolution and file format.
         * You can add custom ways to read URLs and extract information here.
         */
        urlParsers?: ResolveURLParser[];
        /**
         * a list of preferOrders that let the resolver know which asset to pick.
         * already built-in we have a texture preferOrders that let the resolve know which asset to prefer
         * if it has multiple assets to pick from (resolution/formats etc)
         */
        preferOrders?: PreferOrder[];
    };
}

export declare const Assets: AssetsClass;

/**
 * A one stop shop for all Pixi resource management!
 * Super modern and easy to use, with enough flexibility to customize and do what you need!
 * @memberof PIXI
 * @namespace Assets
 *
 * Only one Asset Class exists accessed via the Global Asset object.
 *
 * It has four main responsibilities:
 * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities
 * 2. Loads the resources and transforms them into assets that developers understand.
 * 3. Caches the assets and provides a way to access them.
 * 4: Allow developers to unload assets and clear the cache.
 *
 * It also has a few advanced features:
 * 1. Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'
 * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,
 * in-game loading bars can be a thing of the past!
 *
 *
 * Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once.
 *
 * for example:
 *
 * ```
 * import { Assets } from 'pixi.js';
 *
 * promise1 = Assets.load('bunny.png')
 * promise2 = Assets.load('bunny.png')
 *
 * //promise1 === promise2
 * ```
 * here both promises will be the same. Once resolved.. forever resolved! It makes for really easy resource management!
 *
 * Out of the box it supports the following files:
 * * textures (avif, webp, png, jpg, gif)
 * * sprite sheets (json)
 * * bitmap fonts (xml, fnt, txt)
 * * web fonts (ttf, woff, woff2)
 * * json files (json)
 * * text files (txt)
 *
 * More types can be added fairly easily by creating additional loader parsers.
 *
 * ### Textures
 * - Textures are loaded as ImageBitmap on a worker thread where possible.
 * Leading to much less janky load + parse times.
 * - By default, we will prefer to load AVIF and WebP image files if you specify them.
 * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.
 * - Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!
 * - Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images
 *  but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)
 * #### Sprite sheets
 * - it's hard to know what resolution a sprite sheet is without loading it first, to address this
 * there is a naming convention we have added that will let Pixi understand the image format and resolution
 * of the spritesheet via its file name:
 *
 * `my-spritesheet{resolution}.{imageFormat}.json`
 *
 * for example:
 *
 * `my-spritesheet@2x.webp.json` // 2x resolution, WebP sprite sheet
 * `my-spritesheet@0.5x.png.json` // 0.5x resolution, png sprite sheet
 *
 * This is optional! you can just load a sprite sheet as normal,
 * This is only useful if you have a bunch of different res / formatted spritesheets
 *
 * ### Fonts
 * * Web fonts will be loaded with all weights.
 * it is possible to load only specific weights by doing the following:
 *
 * ```
 * import { Assets } from 'pixi.js';
 *
 * // load specific weights..
 * await Assets.load({
 *    data: {
 *      weights: ['normal'], // only loads the weight
 *    },
 *    src: `outfit.woff2`,
 * });
 *
 * // load everything...
 * await Assets.load(`outfit.woff2`);
 * ```
 * ### Background Loading
 * Background loading will load stuff for you passively behind the scenes. To minimize jank,
 * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the
 * background loader is paused and requested assets are loaded as a priority.
 * Don't worry if something is in there that's already loaded, it will just get skipped!
 *
 * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.
 * It's just that this promise will resolve instantly if the asset
 * has already been loaded.
 *
 * ### Manifest and Bundles
 * - Manifest is a JSON file that contains a list of all assets and their properties.
 * - Bundles are a way to group assets together.
 *
 * ```
 * import { Assets } from 'pixi.js';
 *
 * // manifest example
 * const manifest = {
 *   bundles:[{
 *      name:'load-screen',
 *      assets:[
 *          {
 *             name: 'background',
 *             srcs: 'sunset.png',
 *          },
 *          {
 *             name: 'bar',
 *             srcs: 'load-bar.{png,webp}',
 *          }
 *      ]
 *   },
 *   {
 *      name:'game-screen',
 *      assets:[
 *          {
 *             name: 'character',
 *             srcs: 'robot.png',
 *          },
 *          {
 *             name: 'enemy',
 *             srcs: 'bad-guy.png',
 *          }
 *      ]
 *   }]
 * }}
 *
 * await Asset.init({
 *  manifest
 * });
 *
 * // load a bundle..
 * loadScreenAssets = await Assets.loadBundle('load-screen');
 * // load another..
 * gameScreenAssets = await Assets.loadBundle('game-screen');
 * ```
 * @example
 * import { Assets } from 'pixi.js';
 *
 * const bunny = await Assets.load('bunny.png');
 */
export declare class AssetsClass {
    /** the resolver to map various urls */
    resolver: Resolver;
    /**
     * The loader, loads stuff!
     * @type {PIXI.AssetLoader}
     */
    loader: Loader;
    /**
     * The global cache of all assets within PixiJS
     * @type {PIXI.Cache}
     */
    cache: typeof Cache_2;
    /** takes care of loading assets in the background */
    private readonly _backgroundLoader;
    private _detections;
    private _initialized;
    constructor();
    /**
     * Best practice is to call this function before any loading commences
     * Initiating is the best time to add any customization to the way things are loaded.
     *
     * you do not need to call this for the Asset class to work, only if you want to set any initial properties
     * @param options - options to initialize the Asset manager with
     */
    init(options?: AssetInitOptions): Promise<void>;
    /**
     * Allows you to specify how to resolve any assets load requests.
     * There are a few ways to add things here as shown below:
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // simple
     * Assets.add('bunnyBooBoo', 'bunny.png');
     * const bunny = await Assets.load('bunnyBooBoo');
     *
     * // multiple keys:
     * Assets.add(['burger', 'chicken'], 'bunny.png');
     *
     * const bunny = await Assets.load('burger');
     * const bunny2 = await Assets.load('chicken');
     *
     * // passing options to to the object
     * Assets.add(
     *     'bunnyBooBooSmooth',
     *     'bunny{png,webp}',
     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options
     * );
     *
     * // multiple assets,
     *
     * // the following all do the same thing:
     *
     * Assets.add('bunnyBooBoo', 'bunny{png,webp}');
     *
     * Assets.add('bunnyBooBoo', [
     * 'bunny.png',
     * 'bunny.webp'
     * ]);
     *
     * Assets.add('bunnyBooBoo', [
     *    {
     *       format:'png',
     *       src:'bunny.png',
     *    },
     *    {
     *       format:'webp',
     *       src:'bunny.webp',
     *    }
     * ]);
     *
     * const bunny = await Assets.load('bunnyBooBoo'); // will try to load WebP if available
     * @param keysIn - the key or keys that you will reference when loading this asset
     * @param assetsIn - the asset or assets that will be chosen from when loading via the specified key
     * @param data - asset-specific data that will be passed to the loaders
     * - Useful if you want to initiate loaded objects with specific data
     */
    add(keysIn: string | string[], assetsIn: string | (ResolveAsset | string)[], data?: unknown): void;
    /**
     * Loads your assets! You pass in a key or URL and it will return a promise that
     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.
     *
     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded
     * once and the same promise reused behind the scenes so you can safely call this function multiple
     * times with the same key and it will always return the same asset.
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // load a URL:
     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
     *
     * Assets.add('thumper', 'bunny.png');
     * Assets.add('chicko', 'chicken.png');
     *
     * // load multiple assets:
     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}
     * @param urls - the urls to load
     * @param onProgress - optional function that is called when progress on asset loading is made.
     * The function is passed a single parameter, `progress`, which represents the percentage
     * (0.0 - 1.0) of the assets loaded.
     * @returns - the assets that were loaded, either a single asset or a hash of assets
     */
    load<T = any>(urls: string | string[] | LoadAsset | LoadAsset[], onProgress?: ProgressCallback): Promise<T | Record<string, T>>;
    /**
     * This adds a bundle of assets in one go so that you can load them as a group.
     * For example you could add a bundle for each screen in you pixi app
     * @example
     *  PIXI.Assets.addBundle('animals', {
     *    bunny: 'bunny.png',
     *    chicken: 'chicken.png',
     *    thumper: 'thumper.png',
     *  });
     *
     * const assets = await PIXI.Assets.loadBundle('animals');
     * @param bundleId - the id of the bundle to add
     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
     */
    addBundle(bundleId: string, assets: ResolverBundle['assets']): void;
    /**
     * Bundles are a way to load multiple assets at once.
     * If a manifest has been provided to the init function then you can load a bundle, or bundles.
     * you can also add bundles via `addBundle`
     * @example
     * // manifest example
     * const manifest = {
     *   bundles:[{
     *      name:'load-screen',
     *      assets:[
     *          {
     *             name: 'background',
     *             srcs: 'sunset.png',
     *          },
     *          {
     *             name: 'bar',
     *             srcs: 'load-bar.{png,webp}',
     *          }
     *      ]
     *   },
     *   {
     *      name:'game-screen',
     *      assets:[
     *          {
     *             name: 'character',
     *             srcs: 'robot.png',
     *          },
     *          {
     *             name: 'enemy',
     *             srcs: 'bad-guy.png',
     *          }
     *      ]
     *   }]
     * }}
     *
     * await Asset.init({
     *  manifest
     * });
     *
     * // load a bundle..
     * loadScreenAssets = await PIXI.Assets.loadBundle('load-screen');
     * // load another..
     * gameScreenAssets = await PIXI.Assets.loadBundle('game-screen');
     * @param bundleIds - the bundle id or ids to load
     * @param onProgress - optional function that is called when progress on asset loading is made.
     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
     * of the assets loaded.
     * @returns all the bundles assets or a hash of assets for each bundle specified
     */
    loadBundle(bundleIds: string | string[], onProgress?: ProgressCallback): Promise<any>;
    /**
     * Initiate a background load of some assets. it will passively begin to load these assets in the background.
     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
     *
     * An example of this might be that you would background load game assets after your inital load.
     * then when you got to actually load your game screen assets when a player goes to the game - the loading
     * would already have stared or may even be complete, saving you having to show an interim load bar.
     * @example
     * PIXI.Assets.backgroundLoad('bunny.png');
     *
     * // later on in your app...
     * await PIXI.Assets.loadBundle('bunny.png'); // will resolve quicker as loading may have completed!
     * @param urls - the url / urls you want to background load
     */
    backgroundLoad(urls: string | string[]): Promise<void>;
    /**
     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
     * this can only be used if the loader has been initiated with a manifest
     * @example
     * await PIXI.Assets.init({
     *    manifest: {
     *       bundles: [
     *       {
     *          name:'load-screen',
     *          assets:[...]
     *       }
     *       ...]
     *   }
     * });
     *
     * PIXI.Assets.backgroundLoadBundle('load-screen');
     *
     * // later on in your app...
     * await PIXI.Assets.loadBundle('load-screen'); // will resolve quicker as loading may have completed!
     * @param bundleIds - the bundleId / bundleIds you want to background load
     */
    backgroundLoadBundle(bundleIds: string | string[]): Promise<void>;
    /**
     * Only intended for development purposes.
     * This will wipe the resolver and caches.
     * You will need to reinitialize the Asset
     */
    reset(): void;
    /**
     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,
     * it will return undefined. So it's on you! When in doubt just use `PIXI.Assets.load` instead.
     * (remember, the loader will never load things more than once!)
     * @param keys - The key or keys for the assets that you want to access
     * @returns - The assets or hash of assets requested
     */
    get<T = any>(keys: string | string[]): T | Record<string, T>;
    /**
     * helper function to map resolved assets back to loaded assets
     * @param resolveResults - the resolve results from the resolver
     * @param onProgress - the progress callback
     */
    private _mapLoadToResolve;
    /**
     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
     * this will make sure to destroy any assets and release them from memory.
     * Once unloaded, you will need to load the asset again.
     *
     * Use this to help manage assets if you find that you have a large app and you want to free up memory.
     *
     * * it's up to you as the developer to make sure that textures are not actively being used when you unload them,
     * Pixi won't break but you will end up with missing assets. Not a good look for the user!
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // load a URL:
     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
     *
     * await Assets.unload('http://some.url.com/image.png')
     *
     * myImageTexture <-- will now be destroyed.
     *
     * // unload multiple assets:
     * const textures = await Assets.unload(['thumper', 'chicko']);
     * @param urls - the urls to unload
     */
    unload(urls: string | string[] | LoadAsset | LoadAsset[]): Promise<void>;
    /**
     * Bundles are a way to manage multiple assets at once.
     * this will unload all files in a bundle.
     *
     * once a bundle has been unloaded, you need to load it again to have access to the assets.
     * @example
     * PIXI.Assets.addBundle({
     *   'thumper': 'http://some.url.com/thumper.png',
     * })
     *
     * const assets = await PIXI.Assets.loadBundle('thumper');
     *
     * // now to unload..
     *
     * await await PIXI.Assets.unloadBundle('thumper');
     *
     * // all assets in the assets object will now have been destroyed and purged from the cache
     * @param bundleIds - the bundle id or ids to unload
     */
    unloadBundle(bundleIds: string | string[]): Promise<void>;
    private _unloadFromResolved;
    /** All the detection parsers currently added to the Assets class. */
    get detections(): FormatDetectionParser[];
}

declare const Cache_2: CacheClass;
export { Cache_2 as Cache }

/**
 * A single Cache for all assets.
 *
 * When assets are added to the cache via set they normally are added to the cache as key-value pairs.
 *
 * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.
 * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.
 *
 * This gives devs the flexibility to cache any type of object however we want.
 *
 * It is not intended that this class is created by developers - it is part of the Asset package.
 * This is the first major system of PixiJS' main Assets class.
 * @memberof PIXI
 * @class Cache
 */
declare class CacheClass {
    private _parsers;
    private readonly _cache;
    private readonly _cacheMap;
    /** Clear all entries. */
    reset(): void;
    /**
     * Check if the key exists
     * @param key - The key to check
     */
    has(key: string): boolean;
    /**
     * Fetch entry by key
     * @param key - The key of the entry to get
     */
    get<T = any>(key: string): T;
    /**
     * Set a value by key or keys name
     * @param key - The key or keys to set
     * @param value - The value to store in the cache or from which cacheable assets will be derived.
     */
    set(key: string | string[], value: unknown): void;
    /**
     * Remove entry by key
     *
     * This function will also remove any associated alias from the cache also.
     * @param key - The key of the entry to remove
     */
    remove(key: string): void;
    /** All loader parsers registered */
    get parsers(): CacheParser[];
}

/**
 * For every asset that is cached, it will call the parsers test function
 * the flow is as follows:
 *
 * 1. `cacheParser.test()`: Test the asset.
 * 2. `cacheParser.getCacheableAssets()`: If the test passes call the getCacheableAssets function with the asset
 *
 * Useful if you want to add more than just a raw asset to the cache
 * (for example a spritesheet will want to make all its sub textures easily accessible in the cache)
 */
export declare interface CacheParser<T = any> {
    extension?: ExtensionMetadata;
    /** A config to adjust the parser */
    config?: Record<string, any>;
    /**
     * Gets called by the cache when a dev caches an asset
     * @param asset - the asset to test
     */
    test: (asset: T) => boolean;
    /**
     * If the test passes, this function is called to get the cacheable assets
     * an example may be that a spritesheet object will return all the sub textures it has so they can
     * be cached.
     * @param keys - The keys to cache the assets under
     * @param asset - The asset to get the cacheable assets from
     * @returns A key-value pair of cacheable assets
     */
    getCacheableAssets: (keys: string[], asset: T) => Record<string, any>;
}

export declare const cacheTextureArray: CacheParser<Texture[]>;

export declare function checkExtension(url: string, extension: string | string[]): boolean;

export declare const convertToList: <T>(input: string | T | (string | T)[], transform?: (input: string) => T) => T[];

/**
 * Creates a list of all possible combinations of the given strings.
 * @example
 * const out2 = createStringVariations('name is {chicken,wolf,sheep}');
 * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]
 * @param string - The string to process
 */
export declare function createStringVariations(string: string): string[];

export declare function createTexture(base: BaseTexture, loader: Loader, url: string): Texture<Resource>;

export declare const detectAvif: FormatDetectionParser;

export declare const detectDefaults: FormatDetectionParser;

export declare const detectWebp: FormatDetectionParser;

/**
 * Format detection is useful for detecting feature support
 * on the current platform.
 * @memberof PIXI
 */
export declare interface FormatDetectionParser {
    /** Should be ExtensionType.DetectionParser */
    extension?: ExtensionMetadata;
    /** Browser/platform feature detection supported if return true  */
    test: () => Promise<boolean>;
    /**
     * Add formats (file extensions) to the existing list of formats.
     * Return an new array with added formats, do not mutate the formats argument.
     * @returns {Promise<string[]>} - Promise that resolves to the new formats array.
     */
    add: (formats: string[]) => Promise<string[]>;
    /**
     * Remove formats (file extensions) from the list of supported formats.
     * This is used when uninstalling this DetectionParser.
     * Return an new array with filtered formats, do not mutate the formats argument.
     * @returns {Promise<string[]>} - Promise that resolves to the new formats array.
     */
    remove: (formats: string[]) => Promise<string[]>;
}

/**
 * Return font face name from a file name
 * Ex.: 'fonts/tital-one.woff' turns into 'Titan One'
 * @param url - File url
 */
export declare function getFontFamilyName(url: string): string;

/**
 * Checks if the given value is an array.
 * @param item - The item to test
 */
export declare const isSingleItem: (item: unknown) => boolean;

export declare interface LoadAsset<T = any> {
    src: string;
    data?: T;
    alias?: string[];
    format?: string;
}

/**
 * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.
 * It does not do anything clever with URLs - it just loads stuff!
 * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.
 * Through the use of LoaderParsers, the loader can understand how to load any kind of file!
 *
 * It is not intended that this class is created by developers - its part of the Asset class
 * This is the second major system of PixiJS' main Assets class
 * @memberof PIXI
 * @class AssetLoader
 */
export declare class Loader {
    private _parsers;
    /** Cache loading promises that ae currently active */
    promiseCache: Record<string, PromiseAndParser>;
    /** function used for testing */
    reset(): void;
    /**
     * Used internally to generate a promise for the asset to be loaded.
     * @param url - The URL to be loaded
     * @param data - any custom additional information relevant to the asset being loaded
     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
     */
    private _getLoadPromiseAndParser;
    /**
     * Loads an asset(s) using the parsers added to the Loader.
     * @example
     * // single asset:
     * const asset = await Loader.load('cool.png');
     * console.log(asset);
     * @example
     * // multiple assets:
     * const assets = await  Loader.load(['cool.png', 'cooler.png']);
     * console.log(assets);
     * @param assetsToLoadIn - urls that you want to load, or a single one!
     * @param onProgress - a function that gets called when the progress changes
     */
    load(assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[], onProgress?: (progress: number) => void): Promise<{
        [key: string]: any;
    } | any>;
    /**
     * Unloads an asset(s). Any unloaded assets will be destroyed, freeing up memory for your app.
     * The parser that created the asset, will be the one that unloads it.
     * @example
     * // single asset:
     * const asset = await Loader.load('cool.png');
     *
     * await Loader.unload('cool.png');
     *
     * console.log(asset.destroyed); // true
     * @param assetsToUnloadIn - urls that you want to unload, or a single one!
     */
    unload(assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[]): Promise<void>;
    /** All loader parsers registered */
    get parsers(): LoaderParser[];
}

/**
 * All functions are optional here. The flow:
 *
 * for every asset,
 *
 * 1. `parser.test()`: Test the asset url.
 * 2. `parser.load()`: If test passes call the load function with the url
 * 3. `parser.testParse()`: Test to see if the asset should be parsed by the plugin
 * 4. `parse.parse()`: If test is parsed, then run the parse function on the asset.
 *
 * some plugins may only be used for parsing,
 * some only for loading
 * and some for both!
 */
export declare interface LoaderParser<ASSET = any, META_DATA = any> {
    extension?: ExtensionMetadata;
    /** A config to adjust the parser */
    config?: Record<string, any>;
    /**
     * each URL to load will be tested here,
     * if the test is passed the assets are loaded using the load function below.
     * Good place to test for things like file extensions!
     * @param url - The URL to test
     * @param loadAsset - Any custom additional information relevant to the asset being loaded
     * @param loader - The loader instance
     */
    test?: (url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => boolean;
    /**
     * This is the promise that loads the URL provided
     * resolves with a loaded asset if returned by the parser.
     * @param url - The URL to load
     * @param loadAsset - Any custom additional information relevant to the asset being loaded
     * @param loader - The loader instance
     */
    load?: <T>(url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;
    /**
     * This function is used to test if the parse function should be run on the asset
     * If this returns true then parse is called with the asset
     * @param asset - The loaded asset data
     * @param loadAsset - Any custom additional information relevant to the asset being loaded
     * @param loader - The loader instance
     */
    testParse?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<boolean>;
    /**
     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful than
     * @param asset - The loaded asset data
     * @param loadAsset - Any custom additional information relevant to the asset being loaded
     * @param loader - The loader instance
     */
    parse?: <T>(asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;
    /**
     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset
     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory
     * @param asset - The asset to unload/destroy
     * @param loadAsset - Any custom additional information relevant to the asset being loaded
     * @param loader - The loader instance
     */
    unload?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => void;
}

/**
 * The extension priority for loader parsers.
 * Helpful when managing multiple parsers that share the same extension
 * test. The higher priority parsers will be checked first.
 */
export declare enum LoaderParserPriority {
    /** Generic parsers: txt, json, webfonts */
    Low = 0,
    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */
    Normal = 1,
    /** Specific texture types: svg, png, ktx, dds, basis */
    High = 2
}

export declare type LoadFontData = {
    family: string;
    display: string;
    featureSettings: string;
    stretch: string;
    style: string;
    unicodeRange: string;
    variant: string;
    weights: string[];
};

/**
 * Returns a promise that resolves an ImageBitmaps.
 * This function is designed to be used by a worker.
 * Part of WorkerManager!
 * @param url - The image to load an image bitmap for
 */
export declare function loadImageBitmap(url: string): Promise<ImageBitmap>;

/** simple loader plugin for loading json data */
export declare const loadJson: LoaderParser<any, any>;

/** Loads SVG's into Textures */
export declare const loadSVG: LoaderParser<string | Texture<Resource>, IBaseTextureOptions<any>>;

/**
 * Loads our textures!
 * this makes use of imageBitmaps where available.
 * We load the ImageBitmap on a different thread using the WorkerManager
 * We can then use the ImageBitmap as a source for a Pixi Texture
 */
export declare const loadTextures: LoaderParser<Texture<Resource>, IBaseTextureOptions<any>>;

/** Simple loader plugin for loading text data */
export declare const loadTxt: LoaderParser<any, any>;

/** Web font loader plugin */
export declare const loadWebFont: LoaderParser<FontFace | FontFace[], any>;

/**
 * A prefer order lets the resolver know which assets to prefer depending on the various parameters passed to it.
 * @memberof PIXI
 */
export declare interface PreferOrder {
    /** the importance order of the params */
    priority?: string[];
    params: {
        [key: string]: any;
    };
}

export declare type ProgressCallback = (progress: number) => void;

export declare interface PromiseAndParser {
    promise: Promise<any>;
    parser: LoaderParser;
}

/**
 * the object returned when a key is resolved to an asset.
 * it will contain any additional information passed in the asset was added.
 * @memberof PIXI
 */
export declare interface ResolveAsset extends Record<string, any> {
    alias?: string[];
    src: string;
}

/**
 * A class that is responsible for resolving mapping asset URLs to keys.
 * At its most basic it can be used for Aliases:
 *
 * ```
 * resolver.add('foo', 'bar');
 * resolver.resolveUrl('foo') // => 'bar'
 * ```
 *
 * It can also be used to resolve the most appropriate asset for a given URL:
 *
 * ```
 *  resolver.prefer({
 *      params:{
 *          format:'webp',
 *          resolution: 2,
 *      }
 *  })
 *
 *  resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
 *
 *  resolver.resolveUrl('foo') // => 'bar@2x.webp'
 * ```
 * Other features include:
 * - Ability to process a manifest file to get the correct understanding of how to resolve all assets
 * - Ability to add custom parsers for specific file types
 * - Ability to add custom prefer rules
 *
 * This class only cares about the URL, not the loading of the asset itself.
 *
 * It is not intended that this class is created by developers - its part of the Asset class
 * This is the third major system of PixiJS' main Assets class
 * @memberof PIXI
 */
export declare class Resolver {
    private _assetMap;
    private _preferredOrder;
    private _parsers;
    private _resolverHash;
    private _rootPath;
    private _basePath;
    private _manifest;
    private _bundles;
    /**
     * Let the resolver know which assets you prefer to use when resolving assets.
     * Multiple prefer user defined rules can be added.
     * @example
     * resolver.prefer({
     *     // first look for something with the correct format, and then then correct resolution
     *     priority: ['format', 'resolution'],
     *     params:{
     *         format:'webp', // prefer webp images
     *         resolution: 2, // prefer a resolution of 2
     *     }
     * })
     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
     * resolver.resolveUrl('foo') // => 'bar@2x.webp'
     * @param preferOrders - the prefer options
     */
    prefer(...preferOrders: PreferOrder[]): void;
    /**
     * Set the base path to prepend to all urls when resolving
     * @example
     * resolver.basePath = 'https://home.com/';
     * resolver.add('foo', 'bar.ong');
     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
     * @param basePath - the base path to use
     */
    set basePath(basePath: string);
    get basePath(): string;
    /**
     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
     * default value for browsers is `window.location.origin`
     * @example
     * // Application hosted on https://home.com/some-path/index.html
     * resolver.basePath = 'https://home.com/some-path/';
     * resolver.rootPath = 'https://home.com/';
     * resolver.add('foo', '/bar.png');
     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
     * @param rootPath - the root path to use
     */
    set rootPath(rootPath: string);
    get rootPath(): string;
    /**
     * All the active URL parsers that help the parser to extract information and create
     * an asset object-based on parsing the URL itself.
     *
     * Can be added using the extensions API
     * @example
     * resolver.add('foo', [
     *    {
     *      resolution:2,
     *      format:'png'
     *      src: 'image@2x.png'
     *    },
     *    {
     *      resolution:1,
     *      format:'png'
     *      src: 'image.png'
     *    }
     * ]);
     *
     * // with a url parser the information such as resolution and file format could extracted from the url itself:
     * extensions.add({
     *     extension: ExtensionType.ResolveParser,
     *     test: loadTextures.test, // test if url ends in an image
     *     parse: (value: string) =>
     *     ({
     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
     *         format: value.split('.').pop(),
     *         src: value,
     *     }),
     * });
     *
     * // now resolution and format can be extracted from the url
     * resolver.add('foo', [
     *    'image@2x.png'
     *    'image.png'
     * ]);
     * @
     */
    get parsers(): ResolveURLParser[];
    /** Used for testing, this resets the resolver to its initial state */
    reset(): void;
    /**
     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
     * generally a manifest would be built using a tool.
     * @param manifest - the manifest to add to the resolver
     */
    addManifest(manifest: ResolverManifest): void;
    /**
     * This adds a bundle of assets in one go so that you can resolve them as a group.
     * For example you could add a bundle for each screen in you pixi app
     * @example
     *  resolver.addBundle('animals', {
     *    bunny: 'bunny.png',
     *    chicken: 'chicken.png',
     *    thumper: 'thumper.png',
     *  });
     *
     * const resolvedAssets = await resolver.resolveBundle('animals');
     * @param bundleId - The id of the bundle to add
     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
     */
    addBundle(bundleId: string, assets: ResolverBundle['assets']): void;
    /**
     * Tells the resolver what keys are associated with witch asset.
     * The most important thing the resolver does
     * @example
     * // single key, single asset:
     * resolver.add('foo', 'bar.png');
     * resolver.resolveUrl('foo') // => 'bar.png'
     *
     * // multiple keys, single asset:
     * resolver.add(['foo', 'boo'], 'bar.png');
     * resolver.resolveUrl('foo') // => 'bar.png'
     * resolver.resolveUrl('boo') // => 'bar.png'
     *
     * // multiple keys, multiple assets:
     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);
     * resolver.resolveUrl('foo') // => 'bar.png'
     *
     * // add custom data attached to the resolver
     * Resolver.add(
     *     'bunnyBooBooSmooth',
     *     'bunny{png,webp}',
     *     {scaleMode:SCALE_MODES.NEAREST} // base texture options
     * );
     *
     * resolver.resolve('bunnyBooBooSmooth') // => {src: 'bunny.png', data: {scaleMode: SCALE_MODES.NEAREST}}
     * @param keysIn - The keys to map, can be an array or a single key
     * @param assetsIn - The assets to associate with the key(s)
     * @param data - The data that will be attached to the object that resolved object.
     */
    add(keysIn: string | string[], assetsIn: string | ResolveAsset | (ResolveAsset | string)[], data?: unknown): void;
    /**
     * If the resolver has had a manifest set via setManifest, this will return the assets urls for
     * a given bundleId or bundleIds.
     * @example
     * // manifest example
     * const manifest = {
     *   bundles:[{
     *      name:'load-screen',
     *      assets:[
     *          {
     *             name: 'background',
     *             srcs: 'sunset.png',
     *          },
     *          {
     *             name: 'bar',
     *             srcs: 'load-bar.{png,webp}',
     *          }
     *      ]
     *   },
     *   {
     *      name:'game-screen',
     *      assets:[
     *          {
     *             name: 'character',
     *             srcs: 'robot.png',
     *          },
     *          {
     *             name: 'enemy',
     *             srcs: 'bad-guy.png',
     *          }
     *      ]
     *   }]
     * }}
     * resolver.setManifest(manifest);
     * const resolved = resolver.resolveBundle('load-screen');
     * @param bundleIds - The bundle ids to resolve
     * @returns All the bundles assets or a hash of assets for each bundle specified
     */
    resolveBundle(bundleIds: string | string[]): Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>;
    /**
     * Does exactly what resolve does, but returns just the URL rather than the whole asset object
     * @param key - The key or keys to resolve
     * @returns - The URLs associated with the key(s)
     */
    resolveUrl(key: string | string[]): string | Record<string, string>;
    /**
     * Resolves each key in the list to an asset object.
     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic
     * of finding which asset to return based on any preferences set using the `prefer` function
     * by default the same key passed in will be returned if nothing is matched by the resolver.
     * @example
     * resolver.add('boo', 'bunny.png');
     *
     * resolver.resolve('boo') // => {src:'bunny.png'}
     *
     * // will return the same string as no key was added for this value..
     * resolver.resolve('another-thing.png') // => {src:'another-thing.png'}
     * @param keys - key or keys to resolve
     * @returns - the resolve asset or a hash of resolve assets for each key specified
     */
    resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>;
    /**
     * Internal function for figuring out what prefer criteria an asset should use.
     * @param assets
     */
    private _getPreferredOrder;
}

export declare type ResolverAssetsArray = {
    name: string | string[];
    srcs: string | ResolveAsset[];
}[];

export declare type ResolverAssetsObject = Record<string, (string | ResolveAsset)>;

/**
 * Structure of a bundle found in a manfest file
 * @memberof PIXI
 */
export declare interface ResolverBundle {
    name: string;
    assets: ResolverAssetsArray | ResolverAssetsObject;
}

/**
 * The expected format of a manifest. This would normally be auto generated ar made by the developer
 * @memberof PIXI
 */
export declare type ResolverManifest = {
    bundles: ResolverBundle[];
};

export declare const resolveTextureUrl: ResolveURLParser;

/**
 * Format for url parser, will test a string and if it pass will then parse it, turning it into an ResolveAsset
 * @memberof PIXI
 */
export declare interface ResolveURLParser {
    extension?: ExtensionMetadata;
    /** A config to adjust the parser */
    config?: Record<string, any>;
    /** the test to perform on the url to determin if it should be parsed */
    test: (url: string) => boolean;
    /** the function that will convert the url into an object */
    parse: (value: string) => ResolveAsset;
}

export { }
